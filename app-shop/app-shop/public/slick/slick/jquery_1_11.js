/ *! jQuery v1.11.0 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license * /
! function (a, b) {"object" == typeof module && "object" == typeof module.exports? module.exports = a.document? b (a,! 0): function (a) {if (! a .documento) lanzar un nuevo error ("jQuery requiere una ventana con un documento"); devolver b (a)}: b (a)} ("undefined"! = typeof window? window: this, function (a, b) { var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = " ".trim, l = {}, m =" 1.11.0 ", n = function (a, b) {return new n.fn.init (a, b)}, o = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g, p = / ^ - ms - /, q = / - ([\ da-z]) / gi, r = función (a, b) { return b.toUpperCase ()}; n.fn = n.prototype = {jquery: m, constructor: n, selector: "", length: 0, toArray: function () {return d.call (this)}, get : function (a) {return null! = a? 0> a? this [a + this.length]: this [a]: d.call (this)}, pushStack: function (a) {var b = n. fusionar (this.constructor (), a); devolver b.prevObject = this, b.context = this.context, b}, each: function (a, b) {return n.each (this, a, b)}, map: function (a) {return this.pushStack (n .map (this, function (b, c) {return a.call (b, c, b)}))}, slice: function () {return this.pushStack (d.apply (this, argumentos))}, first: function () {return this.eq (0)}, last: function () {return this.eq (-1)}, eq: function (a) {var b = this.length, c = + a + ( 0> a? B: 0); devolver this.pushStack (c> = 0 && b> c? [This [c]]: [])}, end: function () {return this.prevObject || this.constructor (null )}, push: f, sort: c.sort, splice: c.splice}, n.extend = n.fn.extend = function () {var a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = argumentos.longitud, j =! 1; para ("booleano" == tipo de g && (j = g, g = argumentos [h] || {}, h ++) , "objeto" == typeof g || n.isFunction (g) || (g = {}), h === i && (g = this, h -); i> h; h ++) if (null! = (e = argumentos [h])) para (d en e) a = g [d], c = e [d], g! == c && (j &&c && (n.isPlainObject (c) || ​​(b = n.isArray (c)))? (b? (b =! 1, f = a && n.isArray (a)? a: []): f = a && n. isPlainObject (a)? a: {}, g [d] = n.extende (j, f, c)): vacío 0! == c && (g [d] = c)); return g}, n.extend ({expando: "jQuery" + (m + Math.random ()). replace (/ \ D / g, ""), isReady:! 0, error: function (a) {arrojar nuevo Error (a)}, noop: function () {}, isFunction: function (a) {return "function" === n.type (a)}, isArray: Array.isArray || function (a) {return "array" === n .type (a)}, isWindow: function (a) {return null! = a && a == a.window}, isNumeric: function (a) {return a-parseFloat (a)> = 0}, isEmptyObject: function (a ) {var b; para (b en a) return! 1; return! 0}, isPlainObject: function (a) {var b; if (! a || "objeto"! == n.type (a) || a.nodeType || n.isWindow (a)) return! 1; intente {if (a.constructor &&! j.call (a, "constructor") &&! j.call (a.constructor.prototype,"isPrototypeOf")) return! 1} catch (c) {return! 1} if (l.ownLast) para (b in a) return j.call (a, b); for (b in a); return nulo 0 === b || j.call (a, b)}, escriba: function (a) {return null == a? a + "": "object" == typeof a || "function" == typeof a? h [i.call (a)] || "objeto": tipo de a}, globalEval: function (b) {b && n.trim (b) && (a.execScript || function (b) {a.eval.call ( a, b)}) (b)}, camelCase: function (a) {return a.replace (p, "ms -"). replace (q, r)}, nodeName: function (a, b) {return a .nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, cada una: función (a, b, c) {var d, e = 0, f = a.length, g = s (a); if (c) {if (g) {para (; f> e; e ++) if (d = b.apply (a [e], c), d ===! 1) break} else para (e in a) if (d = b.apply (a [e], c), d ===! 1) break} else if (g) {para (; f> e; e ++) if (d = b.call (a [ e], e, a [e]), d ===! 1) break} else para (e in a) if (d = b.call (a [e], e, a [e]), d = ==! 1) break; return a}, recortar:k &&! k.call ("\ ufeff \ xa0")? function (a) {return null == a? "": k.call (a)}: function (a) {return null == a? "": (a + ""). replace (o, "")}, makeArray: function (a, b) {var c = b || []; return null! = a && (s (Object (a))? n.merge (c, "string" == typeof a? [a]: a): f.call (c, a)), c}, inArray: function (a, b, c) {var d; if (b) { si (g) devuelve g.call (b, a, c); para (d = b.length, c = c? 0> c? Math.max (0, d + c): c: 0; d> c ; c ++) si (c en b && b [c] === a) return c} return-1}, fusionar: función (a, b) {var c = + b.length, d = 0, e = a.length ; while (c> d) a [e ++] = b [d ++]; if (c! == c) while (void 0! == b [d]) a [e ++] = b [d ++]; return a. longitud = e, a}, grep: función (a, b, c) {para (var d, e = [], f = 0, g = a.length, h =! c; g> f; f ++) d =! b (a [f], f), d! == h && e.push (a [f]); return e}, map: function (a, b, c) {var d, f = 0, g = a.length, h = s (a), i = []; if (h) para (; g> f; f ++) d = b (a [f], f, c), null! = d && i.push ( re);else for (f en a) d = b (a [f], f, c), null! = d && i.push (d); return e.apply ([], i)}, guid: 1, proxy: function (a, b) {var c, e, f; devuelve "cadena" == tipo de b && (f = a [b], b = a, a = f), n.isFunction (a)? (c = d. call (argumentos, 2), e = función () {devolver a.apply (b || esto, c.concat (d.call (argumentos)))}, e.guid = a.guid = a.guid || n.guid ++, e): void 0}, now: function () {return + new Date}, support: l}), n.each ("Función de cadena de números booleanos Array de fecha RegExp Object Error" .split ("") , función (a, b) {h ["[objeto" + b + "]"] = b.toLowerCase ()}); función s (a) {var b = a.length, c = n.tipo (a) ; devuelve "function" === c || n.isWindow (a) ?! 1: 1 === a.nodeType && b?! 0: "array" === c || 0 === b || "número "== typeof b && b> 0 && b-1 en a} var t = función (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p , q, r, s = "chisporroteo" + - nueva fecha, t = a.document, u = 0,v = 0, w = eb (), x = eb (), y = eb (), z = función (a, b) {devolver a === b && (j =! 0), 0}, A = " indefinido ", B = 1 << 31, C = {}. hasOwnProperty, D = [], E = D.pop, F = D.push, G = D.push, H = D.slice, I = D. indexOf || función (a) {para (var b = 0, c = this.length; c> b; b ++) if (this [b] === a) return b; return-1}, J = "seleccionado | seleccionado | async | autofocus | reproducción automática | controles | diferir | deshabilitado | oculto | ismap | loop | multiple | open | readonly | required | scoped ", K =" [\\ x20 \\ t \\ r \\ n \\ f] ", L =" (?: \\\\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", M = L.replace (" w "," w # "), N =" \\ ["+ K +" * ("+ L +") "+ K +" * (?: ([* ^ $ |! ~]? =) "+ K +" * (?: ([ '\ "]) ((?: \\\\. | [^ \\\\)) *?) \\ 3 | (" + M + ") |) |)" + K + "* \\]", O = ":(" + L + ") (?: \\ (((['\"]) ((?: \\\\. | [^ \\\\]) *?) \\ 3 | ( (?: \\\\. | [^ \\\\ () [\\]] | "+ N.replace (3,8) +") *) |. *) \\) |) ",P = new RegExp ("^" + K + "+ | ((?: ^ | [^ \\\\]) (?: \\\\.) *)" + K + "+ $", "g") , Q = nuevo RegExp ("^" + K + "*," + K + "*"), R = nuevo RegExp ("^" + K + "* ([> + ~] |" + K + ")" + K + " * "), S = new RegExp (" = "+ K +" * ([^ \\] '\ "] *?)" + K + "* \\]", "g"), T = new RegExp (O ), U = new RegExp ("^" + M + "$"), V = {ID: new RegExp ("^ # (" + L + ")"), CLASS: new RegExp ("^ \\. (" + L + ")"), TAG: nuevo RegExp ("^ (" + L.replace ("w", "w *") + ")"), ATTR: nuevo RegExp ("^" + N), PSEUDO: nuevo RegExp ("^" + O), CHILD: nuevo RegExp ("^ :( solo | primero | último | nth | nth-last) - (child | of-type) (?: \\ (" + K + "* ( par | impar | (([+ -] |) (\\ d *) n |) "+ K +" * (?: ([+ -] |) "+ K +" * (\\ d +) |)) " + K + "* \\) |)", "i"), bool: new RegExp ("^ (?:" + J + ") $", "i"), needsContext: new RegExp ("^" + K + "* [> + ~] |: (incluso | impar | eq | gt | lt | nth | first | last) (?: \\ ("+ K +" * ((?: - \\ d)? \\ d *) "+ K +" * \\) | ) (? = [^ -] | $) "," i ")}, W = / ^ (?: input | select | textarea | button) $ / i, X = / ^ h \ d $ / i, Y = / ^ [^ {] + \ {\ s * \ [nativo \ w /, Z = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w-] +)) $ /, $ = / [+ ~] /, _ = / '| \\ / g, ab = new RegExp ("\\\\ ([\\ da-f] {1,6}" + K + "? | (" + K + ") |.)", "Ig"), bb = función (a, b, c) {var d = "0x" + b-65536; return d! == d || c? b: 0> d? String.fromCharCode (d + 65536): String.fromCharCode (d >> 10 | 55296,1023 & d | 56320)}; intente {G.apply (D = H.call (t.childNodes) , t.childNodes), D [t.childNodes.length] .nodeType} catch (cb) {G = {apply: D.length? function (a, b) {F.apply (a, H.call (b) )}: función (a, b) {var c = a.length, d = 0; mientras que (a [c ++] = b [d ++]); a.longitud = c-1}}} función db (a, b, d, e) {var f, g, h, i, j, m, p, q, u, v; if ((b? b.ownerDocument | | b: t)! == l && k (b), b = b || l, d = d || [] ,! a || "string"! = typeof a) return d; if (1! == ( i = b.nodeType) && 9! == i) return []; if (n &&! e) {if (f = Z.exec (a)) if (h = f [1]) {if (9 === i) {if (g = b.getElementById (h) ,! g ||! g.parentNode) devuelve d; if (g.id === h) devuelve d.push (g), d} else if (b .ownerDocument && (g = b.ownerDocument.getElementById (h)) && r (b, g) && g.id === h) return d.push (g), d} else {if (f [2]) return G. apply (d, b.getElementsByTagName (a)), d; if ((h = f [3]) && c.getElementsByClassName && b.getElementsByClassName) devuelve G.apply (d, b.getElementsByClassName (h)), d} if (c) .qsa && (! o ||! o.test (a))) {if (q = p = s, u = b, v = 9 === i && a, 1 === i && "objeto"! == b. nodeName.toLowerCase ()) {m = ob (a), (p = b.getAttribute ("id"))? q = p.replace (_, "\\ $ &"): b.setAttribute (" id ", q), q =" [id = '"+ q +"'] ", j = m.length; while (j -) m [j] = q + pb ( m [j]); u = $. prueba (a) && mb (b.parentNode) || b, v = m.join (",")} si (v) prueba {return G.apply (d, u. querySelectorAll (v)), d} catch (w) {} finalmente {p || b.removeAttribute ("id")}}} return xb (a.replace (P, "$ 1"), b, d, e) } function eb () {var a = []; function b (c, e) {return a.push (c + "")> d.cacheLength && delete b [a.shift ()], b [c + ""] = e } return b} function fb (a) {return a [s] =! 0, a} function gb (a) {var b = l.createElement ("div"); intente {return !! a (b)} catch (c) {return! 1} finalmente {b.parentNode && b.parentNode.removeChild (b), b = null}} función hb (a, b) {var c = a.split ("|"), e = a. length; while (e -) d.attrHandle [c [e]] = b} función ib (a, b) {var c = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType &&(~ b.sourceIndex || B) - (~ a.sourceIndex || B); if (d) devuelve d; if (c) while (c = c.nextSibling) if (c === b) return-1 ; return a? 1: -1} function jb (a) {return function (b) {var c = b.nodeName.toLowerCase (); return "input" === c && b.type === a}} function kb (a) {función de retorno (b) {var c = b.nodeName.toLowerCase (); return ("input" === c || "button" === c) && b.type === a}} función lb (a) {return fb (función (b) {return b = + b, fb (función (c, d) {var e, f = a ([], c.length, b), g = f.length ; while (g -) c [e = f [g]] && (c [e] =! (d [e] = c [e]))})})} function mb (a) {return a && typeof a .getElementsByTagName! == A && a} c = db.support = {}, f = db.isXML = función (a) {var b = a && (a.ownerDocument || a) .documentElement; return b? "HTML"! = = b.nodeName:! 1}, k = db.setDocument = function (a) {var b, e = a? a.a.ownerDocument || a: t, g = e.defaultView; return e! == l && 9 == = e.nodeType && e.documentElement? (l = e, m = e.documentElement, n =! f (e), g && g! == g.top && (g.addEventListener? g.addEventListener ("unload", function () {k ()}, ! 1): g.attachEvent && g.attachEvent ("onunload", function () {k ()})), c.attributes = gb (function (a) {return a.className = "i",! A.getAttribute ( "className")}), c.getElementsByTagName = gb (function (a) {return a.appendChild (e.createComment ("")) ,! a.getElementsByTagName ("*"). length}), c.getElementsByClassName = Y.test (e.getElementsByClassName) && gb (función (a) {return a.innerHTML = "<div class = 'a'> </div> <div class = 'a i'> </div>", a. firstChild.className = "i", 2 === a.getElementsByClassName ("i"). length}), c.getById = gb (function (a) {return m.appendChild (a) .id = s,! e .getElementsByName ||! e.getElementsByName (s) .length}), c.getById? (d.find.ID = function (a, b) {if (typeof b.getElementById! == A && n) {var c = b.getElementById (a); return c && c.parentNode? [c]: []}, d.filter.ID = function (a) {var b = a.replace (ab, bb); return function (a) {return a.getAttribute ("id" ) === b}}) :( eliminar d.find.ID, d.filter.ID = function (a) {var b = a.replace (ab, bb); devolver la función (a) {var c = typeof a.getAttributeNode! == A && a.getAttributeNode ("id"); devuelve c && c.value === b}}), d.find.TAG = c.getElementsByTagName? function (a, b) {return typeof b.getElementsByTagName! == A? B.getElementsByTagName (a): void 0}: function (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a); if ("*" == = a) {while (c = f [e ++]) 1 === c.nodeType && d.push (c); return d} return f}, d.find.CLASS = c.getElementsByClassName && function (a, b) {return typeof b.getElementsByClassName! == A && n? b.getElementsByClassName (a): void 0}, p = [], o = [], (c.qsa = Y.test (e.querySelectorAll)) && (gb (función (a) {a.innerHTML = "<select t = ''> <option selected = ''> </option> </select>", a.querySelectorAll ("[t ^ = '']"). length && o.push ("[* ^ $] = "+ K +" * (?: '' | \ "\") "), a.querySelectorAll (" [selected] "). Length || o.push (" \\ ["+ K +" * (?: valor | "+ J +") "), a.querySelectorAll (": checked "). length || o.push (": checked ")}), gb (function (a) {var b = e.createElement (" input "); b.setAttribute (" type "," hidden "), a.appendChild (b) .setAttribute (" name "," D "), a.querySelectorAll (" [name = d] "). length && o. push ("nombre" + K + "* [* ^ $ |! ~]? ="), a.querySelectorAll (": enabled"). length || o.push (": enabled", ": disabled"), a.querySelectorAll ("* ,: x"), o.push (",. *:")} )), (c.matchesSelector = Y.test (q = m.webkitMatchesSelector || m.mozMatchesSelector || m.oMatchesSelector || m.msMatchesSelector)) && gb (función (a) {c.disconnectedMatch = q.call) (y , "div"), q.call (a, "[s! = '']: x"), p.push ("! =", O)}), o = o.length && new RegExp (o.join ( "|")), p = p.length && nuevo RegExp (p.join ("|")), b = Y.test (m.compareDocumentPosition), r = b || Y.test (m.contiene)? function ( a, b) {var c = 9 === a.nodeType? a.documentElement: a, d = b && b.parentNode; devolver a === d ||! (! d || 1! == d.nodeType | |! (c.contains? c.contains (d): a.compareDocumentPosition && 16 & a.compareDocumentPosition (d)))}: function (a, b) {if (b) while (b = b.parentNode) if (b == = a) volver!0; return! 1}, z = b? Function (a, b) {if (a === b) return j =! 0,0; var d =! A.compareDocumentPosition-! B.compareDocumentPosition; return d? d: (d = (a.ownerDocument || a) === (b.ownerDocument || b)? a.compareDocumentPosition (b): 1,1 & d ||! c.sortDetached && b.compareDocumentPosition (a) === d ? a === e || a.ownerDocument === t & & r (t, a)? - 1: b === e || b.ownerDocument === t & & r (t, b)? 1: i? I. call (i, a) -I.call (i, b): 0: 4 & d? -1: 1)}: function (a, b) {if (a === b) return j =! 0,0; var c, d = 0, f = a.parentNode, g = b.parentNode, h = [a], k = [b]; if (! f ||! g) devuelve a === e? -1: b === e? 1: f? -1: g? 1: i? I.call (i, a) -I.call (i, b): 0; if (f === g) devuelve ib ( a, b); c = a; mientras que (c = c.parentNode) h.unshift (c); c = b; mientras que (c = c.parentNode) k.unshift (c); mientras que (h [d] = == k [d]) d ++; return d? ib (h [d], k [d]): h [d] === t? -1: k [d] === t? 1: 0} , e): l}, db.matches = function (a, b) {return db (a, null, null, b)}, db.matchesSelector = function (a, b) {if ((a.ownerDocument || a)! == l && k (a), b = b.replace (S, "= '$ 1']"),! (! c.matchesSelector ||! n || p && p.test (b) || o && o.test (b))) intente {var d = q.call (a, b); if (d || c.disconnectedMatch || a.document && 11! == a.document.nodeType) return d} catch (e) {} return db (b, l, null, [a]). length> 0}, db.contains = function (a, b) {return (a.ownerDocument || a)! == l && k (a), r (a, b)}, db.attr = función (a, b) {(a.ownerDocument || a)! == l && k (a); var e = d.attrHandle [b.toLowerCase ()], f = e && C.call (d.attrHandle , b.toLowerCase ())? e (a, b,! n): void 0; return void 0! == f? f: c.attributes ||! n? a.getAttribute (b) :( f = a .getAttributeNode (b)) && f.specified? f.value: null}, db.error = function (a) {arrojar nuevo error ("Error de sintaxis, expresión no reconocida:" + a)}, db.uniqueSort = function (a ) {var b, d = [], e = 0, f = 0; if (j =! c.detectDuplicates, i =! c.sortStable && a.slice (0), a.sort (z),j) {while (b = a [f ++]) b === a [f] && (e = d.push (f)); mientras que (e -) a.splice (d [e], 1)} devuelva i = nulo, a}, e = db.getText = function (a) {var b, c = "", d = 0, f = a.nodeType; if (f) {if (1 === f | | 9 === f || 11 === f) {if ("string" == typeof a.textContent) devolver a.textContent; para (a = a.firstChild; a; a = a.nextSibling) c + = e (a)} else if (3 === f || 4 === f) devuelve a.nodeValue} else while (b = a [d ++]) c + = e (b); return c}, d = db .selectors = {cacheLength: 50, createPseudo: fb, match: V, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", primero:! 0}, "": { dir: "parentNode"}, "+": {dir: "previousSibling", primero:! 0}, "~": {dir: "previousSibling"}}, prefiltro: {ATTR: function (a) {return a [ 1] = a [1]. Reemplazar (ab, bb), a [3] = (a [4] || a [5] || ""). Reemplazar (ab, bb), "~ =" == = a [2] && (a [3] = "" + a [3] + ""), alice (0,4)},NIÑO: función (a) {devolver a [1] = a [1] .toLowerCase (), "nth" === a [1] .slice (0,3)? (A [3] || db.error (a [0]), a [4] = + (a [4]? a [5] + (a [6] || 1): 2 * ("even" === a [3] || " impar "=== a [3])), a [5] = + (a [7] + a [8] ||" impar "=== a [3])): a [3] && db.error (a [0]), a}, PSEUDO: función (a) {var b, c =! a [5] && a [2]; return V.CHILD.test (a [0])? null: (a [ 3] && void 0! == a [4]? A [2] = a [4]: ​​c && T.test (c) && (b = ob (c,! 0)) && (b = c.indexOf (") ", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = c.slice (0, b)), a.slice (0,3))}}, filtro: {TAG: function (a) {var b = a.replace (ab, bb) .toLowerCase (); return "*" === a? Function () {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASS: function (a) {var b = w [a + ""]; return b || (b = new RegExp ("(^ |" + K + ")" + a + "(" + K + "| $)") && w (a, función (a) {return b.test ("string" == tipo de a.className && a.className || tipo de a.getAttribute! == A && a.getAttribute ("class") || "")))} , ATTR: función (a, b, c) {return function (d) {var e = db.attr (d, a); return null == e? "! =" === b: b? (E + = "", "=" === b? e === c: "! =" === b? e! == c: "^ =" === b? c && 0 === e.indexOf (c ): "* =" === b? c && e.indexOf (c)> - 1: "$ =" === b? c && e.slice (-c.length) === c: "~ =" == = b? ("" + e + "") .indexOf (c)> - 1: "| =" === b? e === c || e.slice (0, c.length + 1) == = c + "-" :! 1) :! 0}}, CHILD: función (a, b, c, d, e) {var f = "nth"! == a.slice (0,3), g = "last"! == a.slice (-4), h = "of-type" === b; return 1 === d && 0 === e? function (a) {return !! a.parentNode}: función (b, c, i) {var j, k, l, m, n, o, p = f!== g? "nextSibling": "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase (), t =! i &&! h; if (q) {if (f) {while (p) { l = b; while (l = l [p]) if (h? l.nodeName.toLowerCase () === r: 1 === l.nodeType) devuelve! 1; o = p = "only" == = a &&! o && "nextSibling"} return! 0} if (o = [g? q.firstChild: q.lastChild], g && t) {k = q [s] || (q [s] = {}), j = k [a] || [], n = j [0] === u && j [1], m = j [0] === u && j [2], l = n && q.childNodes [n]; mientras que (l = ++ n && l && l [p] || (m = n = 0) || o.pop ()) if (1 === l.nodeType && ++ m && l === b) {k [a] = [u, n, m]; break}} else if (t && (j = (b [s] || (b [s] = {})) [a]) && j [0] === u) m = j [1 else; while while (l = ++ n && l && l [p] || (m = n = 0) || o.pop ()) if ((h? l.nodeName.toLowerCase () === r: 1 == = l.nodeType) && ++ m && (t && ((l [s] || (l [s] = {})) [a] = [u, m]), l === b)) break; return m- = e,m === d || m% d === 0 && m / d> = 0}}}, PSEUDO: función (a, b) {var c, e = d.pseudos [a] || d.setFilters [a .toLowerCase ()] || db.error ("pseudo no admitido:" + a); devuelve e [s]? e (b): e.length> 1? (c = [a, a, "", b] , d.setFilters.hasOwnProperty (a.toLowerCase ())? fb (función (a, c) {var d, f = e (a, b), g = f.length; mientras que (g -) d = I .call (a, f [g]), a [d] =! (c [d] = f [g])}): función (a) {return e (a, 0, c)}): e} }, pseudos: {not: fb (función (a) {var b = [], c = [], d = g (a.replace (P, "$ 1")); return d [s]? fb (function (a, b, c, e) {var f, g = d (a, nulo, e, []), h = a.length; mientras que (h -) (f = g [h]) && (a [h] =! (b [h] = f))}): función (a, e, f) {return b [0] = a, d (b, null, f, c) ,! c.pop ( )}}), tiene: fb (función (a) {return function (b) {return db (a, b) .length> 0}}), contiene: fb (function (a) {return function (b) { return (b.textContent || b.innerText || e (b)). indexOf (a)> - 1}}), lang: fb (function (a) {return U.test (a || "") | db.error ("lang no compatible:" + a), a = a.replace (ab, bb) .toLowerCase (), function (b) {var c; do if (c = n? b.lang: b.getAttribute (" xml: lang ") || b.getAttribute (" lang ")) devuelve c = c.toLowerCase (), c === a || 0 === c.indexOf (a +" - "); while ((b = b.parentNode) && 1 === b.nodeType); return! 1}}), target: function (b) {var c = a.location && a.location.hash; return c && c.slice (1) === b .id}, root: function (a) {return a === m}, focus: function (a) {return a === l.activeElement && (! l.hasFocus || l.hasFocus ()) && !! (a.type || a.href || ~ a.tabIndex)}, enabled: function (a) {return a.disabled ===! 1}, disabled: function (a) {return a.disabled === ! 0}, seleccionado: function (a) {var b = a.nodeName.toLowerCase (); devolver "input" === b && !! a.checked || "option" === b && !! a.selected} , selected: function (a) {return a.parentNode && a.parentNode.selectedIndex, a.selected ===! 0}, empty: function (a) {for (a = a.firstChild; a; a = a.nextSibling) si (a.nodeType <6) return! 1; return! 0 }, parent: function (a) {return! d.pseudos.empty (a)}, header: function (a) {return X.test (a.nodeName)}, input: function (a) {return W.test (a.nodeName)}, button: function (a) {var b = a.nodeName.toLowerCase (); devolver "input" === b && "button" === a.type || "button" === b}, text: function (a) {var b; devolver "input" === a.nodeName.toLowerCase () && "text" === a.type && (null == (b = a.getAttribute ("type ")) ||" texto "=== b.toLowerCase ())}, primero: lb (function () {return [0]}), last: lb (function (a, b) {return [b-1 ]}), eq: lb (función (a, b, c) {return [0> c? c + b: c]}), incluso: lb (función (a, b) {para (var c = 0; b> c; c + = 2) a.push (c); devolver a}), impar: lb (función (a, b) {para (var c = 1; b> c; c + = 2) a.push ( c); devolver a}), lt:lb (función (a, b, c) {para (var d = 0> c? c + b: c; - d> = 0;) a.push (d); devolver a}), gt: lb ( función (a, b, c) {para (var d = 0> c? c + b: c; ++ d <b;) a.push (d); return a})}}, d.pseudos.nth = d.pseudos.eq; para (b en {radio:! 0, casilla de verificación:! 0, archivo:! 0, contraseña:! 0, imagen:! 0}) d.pseudos [b] = jb (b); para (b en {enviar:! 0, restablecer:! 0}) d.pseudos [b] = kb (b); función nb () {} nb.prototype = d.filters = d.pseudos, d.setFilters = nueva nb; función ob (a, b) {var c, e, f, g, h, i, j, k = x [a + ""]; si (k) devuelve b? 0: k.slice (0) ; h = a, i = [], j = d.preFilter; mientras que (h) {(! c || (e = Q.exec (h))) && (e && (h = h.slice (e [0 ] .length) || h), i.push (f = [])), c =! 1, (e = R.exec (h)) && (c = e.shift (), f.push ({ valor: c, escriba: e [0] .replace (P, "")}), h = h.slice (c.length)); para (g en d.filter)! (e = V [g]. exec (h)) || j [g] &&! (e = j [g] (e)) || (c = e.shift (), f.push ({value: c, tipo: g, coincidencias: e}), h = h.slice (c.length)); if (! c) break} return b? h.length: h? db.error (a): x (a, i) .slice (0)} función pb (a) {para (var b = 0, c = a.length, d = ""; c> b; b ++) d + = a [b] .value; return d} función qb (a, b, c) {var d = b.dir, e = c && "parentNode" === d, f = v ++; return b.first? function (b, c, f) {while (b = b [d]) if (1 === b.nodeType || e) devuelve a (b, c, f)}: función (b, c, g) {var h, i, j = [u, f]; if (g) {while (b = b [d]) if ((1 === b.nodeType || e) && a (b, c, g)) return! 0 } else while while (b = b [d]) if (1 === b.nodeType || e) {if (i = b [s] || (b [s] = {}), (h = i [ d]) && h [0] === u && h [1] === f) devuelve j [2] = h [2]; if (i [d] = j, j [2] = a (b, c, g)) return! 0}}} function rb (a) {return a.length> 1? function (b, c, d) {var e = a.length; while (e -) if (! a [e ] (b, c, d)) return! 1; return! 0}: a [0]} función sb (a, b, c, d, e) {para (var f, g = [], h = 0 , i = a.length, j = null! = b; i> h; h ++) (f = a [h]) && (! c || c (f, d, e)) && (g.push (f ), j && b.push (h)); return g} función tb (a, b, c, d, e, f) {return d &&! d [s] && (d = tb (d)), e &&! e [s] && (e = tb (e, f)), fb (función (f, g, h, i) {var j, k, l, m = [], n = [], o = g.length, p = f || wb (b || "*", h.nodeType? [h]: h, []), q =! a ||! f && b ? p: sb (p, m, a, h, i), r = c? e || (f? a: o || d)? []: g: q; if (c && c (q, r, h) , i), d) {j = sb (r, n), d (j, [], h, i), k = longitud j, mientras que (k -) (l = j [k]) && ( r [n [k]] =! (q [n [k]] = l))} if (f) {if (e || a) {if (e) {j = [], k = r.length ; while (k -) (l = r [k]) && j.push (q [k] = l); e (nulo, r = [], j, i)} k = r.length; while (k -) (l = r [k]) && (j = e? I.call (f, l): m [k])> - 1 && (f [j] =! (g [j] = l)) }} else else r = sb (r === g? r.splice (o, r.length): r), e? e (nulo, g, r, i): G.apply (g, r)}) } función ub (a) {para (var b, c, e, f = a.length, g = d.relative [a [0] .type], i = g || d.relative [""], j = g? 1: 0, k = qb (función (a) {return a === b}, i,! 0), l = qb (función (a) {return I.call (b, a)> - 1}, i,! 0), m = [función (a, c, d) {return! G && (d || c! == h) || ((b = c) .nodeType? K (a, c , d): l (a, c,d))}]; f> j; j ++) if (c = d.relative [a [j] .type]) m = [qb (rb (m), c)]; else {if (c = d. filtre [a [j] .type] .apply (null, a [j] .matches), c [s]) {para (e = ++ j; f> e; e ++) if (d.relative [a [ e] .type]) break; devuelve tb (j> 1 && rb (m), j> 1 && pb (a.slice (0, j-1) .concat ({value: "" === a [j-2]. escriba? "*": ""})). replace (P, "$ 1"), c, e> j && ub (a.slice (j, e)), f> e && ub (a = a.slice (e)) , f> e && pb (a))} m.push (c)} devolver la función rb (m)} vb (a, b) {var c = b.length> 0, e = a.length> 0, f = function (f, g, i, j, k) {var m, n, o, p = 0, q = "0", r = f && [], s = [], t = h, v = f || e && d .find.TAG ("*", k), w = u + = null == t? 1: Math.random () || .1, x = v.length; para (k && (h = g! == l && g) ); q! == x && null! = (m = v [q]); q ++) {if (e && m) {n = 0; while (o = a [n ++]) if (o (m, g, i)) {j.push (m); break} k && (u = w)} c ​​&& ((m =! o && m) && p -, f && r.push (m))} if (p + = q, c && q! == p) {n = 0; while (o = b [n ++]) o (r, s, g, i); if (f) {if (p> 0) while (q -) r [q] || s [q] || (s [q] = E.call (j)) s = sb (s)} G .apply (j, s), k &&! f && s.length> 0 && p + b.length> 1 && db.uniqueSort (j)} return k && (u = w, h = t), r}; return c? fb (f): f} g = db.compile = función (a, b) {var c, d = [], e = [], f = y [a + ""]; if (! f) {b || (b = ob (a)), c = b.length; mientras que (c -) f = ub (b [c]), f [s]? d.push (f): e.push (f); f = y ( a, vb (e, d))} return f}; función wb (a, b, c) {para (var d = 0, e = b.length; e> d; d ++) db (a, b [d ], c); devolver c} función xb (a, b, e, f) {var h, i, j, k, l, m = ob (a); if (! f && 1 === m.length) { if (i = m [0] = m [0] .slice (0), i.length> 2 && "ID" === (j = i [0]). tipo && c.getById && 9 === b.nodeType && n && d.relative [i [1] .type]) {if (b = (d.find.ID (j.matches [0] .replace (ab, bb), b) || []) [0] ,! b) return e; a = a.slice (i.shift (). value.length)} h = V.needsContext.test (a)? 0: i.length; while (h -) {if (j = i [h], d.relative [k = j. tipo]) break; if ((l = d.find [k]) && (f = l (j.matches [0] .replace (ab, bb), $. test (i [0] .type) && mb ( b.parentNode) || b))) {if (i.splice (h, 1), a = f.length && pb (i) ,! a) devuelve G.apply (e, f), e; break}}} devuelva g (a, m) (f, b,! n, e, $. test (a) && mb (b.parentNode) || b), e} return c.sortStable = s.split (""). sort (z) .join ("") === s, c.detectDuplicates = !! j, k (), c.sortDetached = gb (función (a) {return 1 & a.compareDocumentPosition (l.createElement ("div") )}), gb (función (a) {return a.innerHTML = "<a href='#'> </a>", "#" === a.firstChild.getAttribute ("href")}) | | hb ("type | href | height | width", función (a, b, c) {return c? void 0: a.getAttribute (b, "type" === b.toLowerCase ()? 1: 2) }), c.attributes &&gb (función (a) {return a.innerHTML = "<input />", a.firstChild.setAttribute ("value", ""), "" === a.firstChild.getAttribute ("value")}) || hb ("valor", función (a, b, c) {return c || "input"! == a.nodeName.toLowerCase ()? void 0: a.defaultValue}), gb (función (a) {return null == a.getAttribute ("disabled")}) || hb (J, función (a, b, c) {var d; return c? void 0: a [b] ===! 0? b .toLowerCase () :( d = a.getAttributeNode (b)) && d.specified? d.value: null}), db} (a); n.find = t, n.expr = t.selectors, n.expr [":"] = n.expr.pseudos, n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains; var u = n.expr .match.needsContext, v = / ^ <(\ w +) \ s * \ /?> (?: <\ / \ 1> |) $ /, w = / ^. [^: # \ [\.,] * $ /; función x (a, b, c) {si (n.isFunction (b)) return n.grep (a, function (a, d) {return !! b.call (a, d, a) ! == c}); si (b.nodeType) return n.grep (a, function (a) {return a === b! == c}); if ("string" == typeof b) {if (w.test (b)) return n. filtro (b, a, c); b = n.filter (b, a)} return n.grep (a, función (a) {return n.inArray (a, b)> = 0! == c}) } n.filter = función (a, b, c) {var d = b [0]; devolver c && (a = ": not (" + a + ")"), 1 === b.length && 1 === d .nodeType? n.find.matchesSelector (d, a)? [d]: []: n.find.matches (a, n.grep (b, function (a) {return 1 === a.nodeType}) )}, n.fn.extend ({find: function (a) {var b, c = [], d = this, e = d.length; if ("string"! = typeof a) devuelve this.pushStack ( n (a) .filter (función () {para (b = 0; e> b; b ++) si (n.contains (d [b], this)) return! 0})); para (b = 0; e> b; b ++) n.find (a, d [b], c); devolver c = this.pushStack (e> 1? n.unique (c): c), c.selector = this.selector? this .selector + "" + a: a, c}, filter: function (a) {return this.pushStack (x (this, a || [] ,! 1))}, no: function (a) {return this.pushStack (x (esto, a || [] ,! 0))}, es: function (a) {return !! x (this, "string" == typeof a && u.test (a)? n (a): a || [] ,! 1) .length}}); var y, z = a.document, A = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] *)) $ /, B = n.fn.init = function (a, b) {var c, d; if (! a) devuelve esto; if ("string" == typeof a) {if (c = "<" === a.charAt (0) && ">" === a.charAt (a.length-1) && a.length> = 3? [null, a, null] : A.exec (a) ,! c ||! C [1] && b) return! B || b.jquery? (B || y) .find (a): this.constructor (b) .find (a if (c [1]) {if (b = b instanceof n? b [0]: b, n.merge (this, n.parseHTML (c [1], b && b.nodeType? b.ownerDocument || b : z,! 0)), v.test (c [1]) && n.isPlainObject (b)) para (c in b) n.isFunction (this [c])? this [c] (b [c]) : this.attr (c, b [c]); devolver esto} if (d = z.getElementById (c [2]), d && d.parentNode) {if (d.id! == c [2]) devolver y .find (a); this.length = 1, este [0] = d} devuelve esto.context = z, this.selector = a, this} return a.nodeType? (this.context = this [0] = a, this.length = 1, this): n.isFunction (a)? "undefined"! = typeof y.ready? y.ready (a): a (n) :( void 0! == a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray (a, this))}; B.prototipo = n.fn, y = n (z); var C = / ^ (?: padres | prev (?: Hasta | Todos)) /, D = {hijos:! 0, contenidos :! 0, siguiente:! 0, prev:! 0}; n.extextend ({dir: function (a, b, c) {var d = [], e = a [b]; while (e && 9! == e.nodeType && (void 0 === c || 1! == e.nodeType ||! n (e) .is (c))) 1 === e.nodeType && d.push (e), e = e b]; return d}, hermano: función (a, b) {para (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a! == b && c.push (a); return c}}), n.fn.extend ({tiene: función (a) {var b, c = n (a, esto), d = c.length; devolver este.filter (función () {para (b = 0; d> b; b ++) if (n.contains (this, c [b])) return! 0})}, closest: function (a, b) {for (var c, d = 0, e = this .longitud,f = [], g = u.test (a) || "string"! = typeof a? n (a, b || this.context): 0; e> d; d ++) para (c = this [d ]; c && c! == b; c = c.parentNode) if (c.nodeType <11 && (g? g.index (c)> - 1: 1 === c.nodeType && n.find.matchesSelector (c, a) )) {f.push (c); break} devolver this.pushStack (f.length> 1? n.unique (f): f)}, index: function (a) {return a? "string" == typeof a? n.inArray (este [0], n (a)): n.inArray (a.jquery? a [0]: a, this): this [0] && this [0] .parentNode? this.first ( ) .prevAll (). length: -1}, agrega: function (a, b) {return this.pushStack (n.unique (n.merge (this.get (), n (a, b))))} , addBack: function (a) {return this.add (null == a? this.prevObject: this.prevObject.filter (a))}}); function E (a, b) {do a = a [b] ; while (a && 1! == a.nodeType); return a} n.each ({parent: function (a) {var b = a.parentNode; return b && 11! == b.nodeType? b: null}, parents: función (a) {return n.dir (a, "parentNode ")}, parentsUntil: function (a, b, c) {return n.dir (a," parentNode ", c)}, next: function (a) {return E (a," nextSibling ")}, prev : function (a) {return E (a, "previousSibling")}, nextAll: function (a) {return n.dir (a, "nextSibling")}, prevAll: function (a) {return n.dir (a , "previousSibling")}, nextUntil: function (a, b, c) {return n.dir (a, "nextSibling", c)}, prevUntil: function (a, b, c) {return n.dir (a , "previousSibling", c)}, hermanos: function (a) {return n.sibling ((a.parentNode || {}). firstChild, a)}, children: function (a) {return n.sibling (a .firstChild)}, contents: function (a) {return n.nodeName (a, "iframe")? a.contentDocument || a.contentWindow.document: n.merge ([], a.childNodes)}}, función (a, b) {n.fn [a] = función (c, d) {var e = n.mapa (esto, b, c); devuelva "Until"! == a.slice (-5) && ( d = c), d && "cadena "== typeof d && (e = n.filter (d, e)), this.length> 1 && (D [a] || (e = n.unique (e)), C.test (a) && ( e = e.reverse ())), this.pushStack (e)}}); var F = / \ S + / g, G = {}; función H (a) {var b = G [a] = {} ; return n.each (a.match (F) || [], función (a, c) {b [c] =! 0}), b} n.Callbacks = function (a) {a = "string" == typeof a? G [a] || H (a): n.extendente ({}, a); var b, c, d, e, f, g, h = [], i =! a.once && [], j = función (l) {para (c = a.memory && l, d =! 0, f = g || 0, g = 0, e = h.length, b =! 0; h && e> f; f ++ ) si (h [f] .apply (l [0], l [1]) ===! 1 && a.stopOnFalse) {c =! 1; break} b =! 1, h && (i? i.length && j (i .shift ()): c? h = []: k.disable ())}, k = {add: function () {if (h) {var d = h.length;! function f (b) {n .each (b, function (b, c) {var d = n.type (c); "function" === d? a.unique && k.has (c) || ​​h.push (c): c && c.length && "string"! == d && f (c)})} (argumentos), b? e = h.length:c && (g = d, j (c))} devolver esto}, remove: function () {return h && n.each (argumentos, función (a, c) {var d; while ((d = n.inArray (c, h, d))> - 1) h.splice (d, 1), b && (e> = d && e -, f> = d && f -)}), this}, has: function (a) {return a? n.inArray (a, h)> - 1:! (! h ||! h.length)}, empty: function () {return h = [], e = 0, this}, disable: function () { return h = i = c = void 0, this}, deshabilitado: function () {return! h}, lock: function () {return i = void 0, c || k.disable (), this}, bloqueado: function () {return! i}, fireWith: function (a, c) {return! h || d &&! i || (c = c || [], c = [a, c.slice? c.slice ( ): c], b? i.push (c): j (c)), this}, fire: function () {return k.fireWith (this, argumentos), this}, fired: function () {return! ! d}}; return k}, n.extextend ({Deferred: function (a) {var b = [["resolver", "done", n.Callbacks ("once memory"), "resolvió"], [ "rechazar", "fallar", n.Las devoluciones de llamada ("once memoria"), "rechazadas"], ["notificar", "progreso", n.Callbacks ("memoria")]], c = "pendiente", d = {estado: función () {retorno c }, siempre: function () {return e.done (argumentos) .fail (argumentos), this}, luego: function () {var a = argumentos; return n.Deferred (function (c) {n.each (b , función (b, f) {var g = n.isFunction (a [b]) && a [b]; e [f [1]] (function () {var a = g && g.apply (esto, argumentos); a && n .isFunction (a.promise)? a.promise (). done (c.resolve) .fail (c.reject) .progress (c.notify): c [f [0] + "With"] (this == = d? c.promise (): this, g? [a]: argumentos)})}), a = null}). promise ()}, promise: function (a) {return null! = a? n. extend (a, d): d}}, e = {}; return d.pipe = d.then, n.each (b, function (a, f) {var g = f [2], h = f [ 3]; d [f [1]] = g.add, h && g.add (función () {c = h}, b [1 ^ a] [2] .disable, b [2] [2] .lock) , e [f [0]] = función () {return e [f [0] + "Con "] (esto === e? D: esto, argumentos), esto}, e [f [0] +" With "] = g.fireWith}), d.promise (e), a && a.call (e , e), e}, cuando: función (a) {var b = 0, c = d.call (argumentos), e = c.length, f = 1! == e || a && n.isFunction (a.promise )? e: 0, g = 1 === f? a: n.Deferred (), h = function (a, b, c) {return function (e) {b [a] = this, c [a] = argumentos.longitud> 1? d.call (argumentos): e, c === i? g.notifyWith (b, c): - f || g.resolveWith (b, c)}}, i, j , k; si (e> 1) para (i = nueva matriz (e), j = nueva matriz (e), k = nueva matriz (e); e> b; b ++) c [b] && n.isFunction (c [b] .promise)? c [b] .promise (). done (h (b, k, c)). fail (g.reject) .progress (h (b, j, i)): - f ; return f || g.resolveWith (k, c), g.promise ()}}); var I; n.fn.ready = function (a) {return n.ready.promise (). done (a) , this}, n.extextend ({isReady:! 1, readyWait: 1, holdReady: function (a) {a? n.readyWait ++: n.ready (! 0)}, ready: function (a) {if (a ===! 0?! - n.readyWait:! N.isReady) {if (! Z.body) devolver setTimeout (n.listo); n.isReady =! 0, a! ==! 0 && - n.readyWait> 0 || (I.resolveWith (z, [n]), n.fn.trigger && n (z) .trigger ("listo ") .off (" ready "))}}}); function J () {z.addEventListener? (z.removeEventListener (" DOMContentLoaded ", K,! 1), a.removeEventListener (" load ", K ,! 1)) :( z.detachEvent ("onreadystatechange", K), a.detachEvent ("onload", K))} función K () {(z.addEventListener || "load" === event.type || "complete" === z.readyState) && (J (), n.ready ())} n.ready.promise = function (b) {if (! I) if (I = n.Deferred (), " complete "=== z.readyState) setTimeout (n.ready); de lo contrario, si (z.addEventListener) z.addEventListener (" DOMContentLoaded ", K,! 1), a.addEventListener (" load ", K,! 1) ; else {z.attachEvent ("onreadystatechange", K), a.attachEvent ("onload", K); var c =! 1; intente {c = null == a.frameElement && z.documentElement} catch (d) {} ​​c && c.doScroll && function e () {if (! n.isReady) {try {c.doScroll ("left")} catch (a) {return setTimeout (e, 50) } J (), n.ready ()}} ()} devolver I. prometer (b)}; var L = "indefinido", M; para (M en n (l)) break; l.ownLast = "0 "! == M, l.inlineBlockNeedsLayout =! 1, n (function () {var a, b, c = z.getElementsByTagName (" body ") [0]; c && (a = z.createElement (" div ") , a.style.cssText = "borde: 0; ancho: 0; altura: 0; posición: absoluta; superior: 0; izquierda: -9999px; margen superior: 1px", b = z.createElement ("div") , c.appendChild (a) .appendChild (b), tipo de b.style.zoom! == L && (b.style.cssText = "border: 0; margin: 0; width: 1px; padding: 1px; display: inline ; zoom: 1 ", (l.inlineBlockNeedsLayout = 3 === b.offsetWidth) && (c.style.zoom = 1)), c.removeChild (a), a = b = null)}), function () {var a = z.createElement ("div"); if (null == l.deleteExpando) {l.deleteExpando =! 0; intente {delete a.test} catch (b) {l.deleteExpando =! 1}} a = null} () , n.acceptData = function (a) {var b = n.noData [(a.nodeName + "") .toLowerCase ()], c = + a.nodeType || 1; return 1! == c && 9! == c ?! 1:! B || b! ==! 0 && a.getAttribute ("classid") === b}; var N = / ^ (?: \ {[\ W \ W] * \} | \ [[ \ w \ W] * \]) $ /, O = / ([AZ]) / g; función P (a, b, c) {if (void 0 === c && 1 === a.nodeType) {var d = "data -" + b.replace (O, "- $ 1"). toLowerCase (); if (c = a.getAttribute (d), "string" == typeof c) {try {c = "true" === c?! 0: "false" === c?! 1: "null" === c? null: + c + "" === c? + c: N.test (c)? n. parseJSON (c): c} catch (e) {} n.data (a, b, c)} else c = void 0} return c} function Q (a) {var b; para (b en a) if ( ("data"! == b ||! n.isEmptyObject (a [b])) && "toJSON"! == b) return! 1; return!0} función R (a, b, d, e) {si (n.acceptData (a)) {var f, g, h = n.expando, i = a.nodeType, j = i? N.cache: a , k = i? a [h]: a [h] && h; if (k && j [k] && (e || j [k] .data) || void 0! == d || "string"! = typeof b) devuelve k || (k = i? a [h] = c.pop () || n.guid ++: h), j [k] || (j [k] = i? {}: {toJSON: n.noop}), ("object" == typeof b || "function" == typeof b) && (e? j [k] = n.extext (j [k], b): j [k]. data = n.extendente (j [k] .data, b)), g = j [k], e || (g.data || (g.data = {}), g = g.data), void 0! == d && (g [n.camelCase (b)] = d), "string" == typeof b? (F = g [b], null == f && (f = g [n.camelCase (b) ])): f = g, fobjeto "== typeof b ||" function "== typeof b) && (e? j [k] = n.extext (j [k], b): j [k] .data = n.extend (j [ k] .data, b)), g = j [k], e || (g.data || (g.data = {}), g = g.data), vacío 0! == d && (g [ n.camelCase (b)] = d), "string" == typeof b? (f = g [b], null == f && (f = g [n.camelCase (b)])): f = g, Fobjeto "== typeof b ||" function "== typeof b) && (e? j [k] = n.extext (j [k], b): j [k] .data = n.extend (j [ k] .data, b)), g = j [k], e || (g.data || (g.data = {}), g = g.data), vacío 0! == d && (g [ n.camelCase (b)] = d), "string" == typeof b? (f = g [b], null == f && (f = g [n.camelCase (b)])): f = g, F
}} función S (a, b, c) {si (n.acceptData (a)) {var d, e, f = a.nodeType, g = f? n.cache: a, h = f? a [n .expando]: n.expando; if (g [h]) {if (b && (d = c? g [h]: g [h] .data)) {n.isArray (b)? b = b.concat (n.map (b, n.camelCase)): b en d? b = [b] :( b = n.camelCase (b), b = b en d? [b]: b.split ("") ), e = b.length; mientras que (e -) borra d [b [e]]; if (c?! Q (d) :! n.isEmptyObject (d)) return} (c || (delete g [h] .data, Q (g [h]))) && (f? n.cleanData ([a] ,! 0): l.deleteExpando || g! = g.window? delete g [h]: g [h] = null)}}} n.extextend ({cache: {}, noData: {"applet":! 0, "embed":! 0, "object": "clsid: D27CDB6E-AE6D-11cf-96B8 -444553540000 "}, hasData: function (a) {return a = a.nodeType? N.cache [a [n.expando]]: a [n.expando], !! a &&! Q (a)}, data: función (a, b, c) {return R (a, b, c)}, removeData: function (a, b) {return S (a, b)}, _ data: function (a, b, c) {return R (a, b, c,! 0)}, _ removeData: function (a, b) {return S (a, b ,!0)}}), n.fn.extend ({data: function (a, b) {var c, d, e, f = this [0], g = f && f.attributes; if (void 0 === a ) {if (this.length && (e = n.data (f), 1 === f.nodeType &&! n._data (f, "parsedAttrs"))) {c = g.length; while (c--) d = g [c] .name, 0 === d.indexOf ("data -") && (d = n.camelCase (d.slice (5)), P (f, d, e [d])) ; n._data (f, "parsedAttrs",! 0)} return e} return "object" == typeof a? this.each (function () {n.data (this, a)}): argumentos.length> 1? This.each (function () {n.data (this, a, b)}): f? P (f, a, n.data (f, a)): void 0}, removeData: function (a ) {return this.each (function () {n.removeData (this, a)})}}), n.extextend ({queue: function (a, b, c) {var d; return a? (b = (b || "fx") + "queue", d = n._data (a, b), c && (! d || n.isArray (c)? d = n._data (a, b, n.makeArray (c)): d.push (c)), d || []): void 0}, dequeue: function (a, b) {b = b || "fx"; var c = n.queue (a , b), d = c.length, e = c.shift (), f = n._queueHooks (a, b), g = function () {n.dequeue (a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ("fx" === b && c.unshift ("inprogress"), eliminar f.stop, e.call (a, g, f)) ,! d && f && f.empty.fire () }, _ queueHooks: function (a, b) {var c = b + "queueHooks"; devolver n._data (a, c) || ​​n._data (a, c, {empty: n.Callbacks ("once memory") .add (function () {n._removeData (a, b + "queue"), n._removeData (a, c)})}}}), n.fn.extend ({queue: function (a, b) {var c = 2; devuelve "string"! = typeof a && (b = a, a = "fx", c -), argumentos.length <c? n.queue (esto [0], a): void 0 === b? this: this.each (function () {var c = n.queue (this, a, b); n._queueHooks (this, a), "fx" === a && "inprogress"! = = c [0] && n.dequeue (this, a)})}, dequeue: function (a) {devuelve this.each (function () {n.dequeue (this, a)})}, clearQueue: function (a) {return this.queue (a || "fx", [])}, promise: function (a, b) {var c, d = 1, e = n.Deferred (), f = this, g = this.length, h = function () {- d || e.resolveWith (f, [f])}; "string"! = typeof a && (b = a, a = void 0), a = a || "fx"; mientras que (g -) c = n._data (f [g], a + "queueHooks"), c && c.empty && (d ++, c.empty .add (h)); return h (), e.promise (b)}}); var T = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [ + -]? \ d + |) /. source, U = ["Top", "Right", "Bottom", "Left"], V = function (a, b) {return a = b || a, " none "=== n.css (a," display ") ||! n.contains (a.ownerDocument, a)}, W = n.access = function (a, b, c, d, e, f, g) {var h = 0, i = a.length, j = null == c; if ("objeto" === n.type (c)) {e =! 0; para (h en c) n. acceso (a, b, h, c [h] ,! 0, f, g)} else if (void 0! == d && (e =! 0, n.isFunction (d) || (g =! 0) , j && (g? (b.call (a, d),b = nulo) :( j = b, b = función (a, b, c) {return j.call (n (a), c)})), b)) para (; i> h; h ++) b (a [h], c, g? d: d.call (a [h], h, b (a [h], c))); devuelva e? a: j? b.call (a): i ? b (a [0], c): f}, X = / ^ (?: casilla de verificación | radio) $ / i;! function () {var a = z.createDocumentFragment (), b = z.createElement (" div "), c = z.createElement (" input "); if (b.setAttribute (" className "," t "), b.innerHTML =" <link/><table> </table> <a href = '/ a'> a </a> ", l.leadingWhitespace = 3 === b.firstChild.nodeType, l.tbody =! b.getElementsByTagName (" tbody "). length, l.htmlSerialize = !! b. getElementsByTagName ("link"). length, l.html5Clone = "<: nav> </: nav>"! == z.createElement ("nav"). cloneNode (! 0) .outerHTML, c.type = "casilla de verificación ", c.checked =! 0, a.appendChild (c), l.appendChecked = c.checked, b.innerHTML =" <textarea> x </textarea>",l.noCloneChecked=!b.cloneNode(!0).lastChild.defaultValue,a.appendChild(b),b.innerHTML="<input type = 'radio' check = = checked 'name =' t '/> ", l.checkClone = b.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, l.noCloneEvent =! 0, b.attachEvent && (b.attachEvent (" onclick ", function () {l.noCloneEvent =! 1}), b.cloneNode (! 0) .click ()), null == l.deleteExpando) {l.deleteExpando =! 0; try {delete b.test} catch (d) { l.deleteExpando =! 1}} a = b = c = null} (), function () {var b, c, d = z.createElement ("div"); para (b en {submit:! 0, cambiar :! 0, focusin:! 0}) c ​​= "on" + b, (l [b + "Bubbles"] = c en a) || (d.setAttribute (c, "t"), l [b + "Bubbles "] = d.attributes [c] .expando ===! 1); d = null} (); var Y = / ^ (?: input | select | textarea) $ / i, Z = / ^ key /, $ = / ^ (?: mouse | contextmenu) | click /, _ = / ^ (?: focusinfocus | focusoutblur) $ /,ab = / ^ ([^.] *) (?: \. (. +) |) $ /; function bb () {return! 0} function cb () {return! 1} function db () {try { return z.activeElement} catch (a) {}} n.event = {global: {}, add: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, o, p, q, r = n._data (a); if (r) {c.handler && (i = c, c = i.handler, e = i.selector), c.guid || (c.guid = n.guid ++), (g = r.events) || (g = r.events = {}), (k = r.handle) || (k = r.handle = function (a) {return typeof n === L || a && n.event.triggered === a.type? void 0: n.event.dispatch.apply (k.elem, argumentos)}, k.elem = a), b = (b || ""). coincidencia (F) || [""], h = b.length; mientras que (h -) f = ab.exec (b [h]) || [], o = q = f [1], p = (f [2] || ""). split ("."). sort (), o && (j = n.event.special [o] || {}, o = ( e? j.delegateType: j.bindType) || o, j = n.event.special [o] || {}, l = n.extender ({type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test (e), espacio de nombres: p.join (".")}, i), (m = g [o]) || (m = g [o] = [], m.delegateCount = 0, j.setup && j.setup.call (a, d, p, k)! ==! 1 || (a.addEventListener? a.addEventListener (o, k,! 1): a.attachEvent && a.attachEvent ("on" + o, k))), j.add && (j .add.call (a, l), l.handler.guid || (l.handler.guid = c.guid)), e? m.splice (m.delegateCount ++, 0, l): m.push (l ), n.event.global [o] =! 0); a = null}}, eliminar: función (a, b, c, d, e) {var f, g, h, i, j, k, l , m, o, p, q, r = n.hasData (a) && n._data (a); if (r && (k = r.events)) {b = (b || ""). match (F) || [""], j = b.length; while (j -) if (h = ab.exec (b [j]) || [], o = q = h [1], p = (h [2] || ""). Split ("."). Sort (), o) {l = n.event.special [o] || {}, o = (d? L.delegateType: l.bindType ) || o, m = k [o] || [], h = h [2] && nuevo RegExp ("(^ | \\.)" + p.join ("\\. (?:. * \\ . |) ") +" (\\. | $) "), i = f = m.length; mientras que (f -) g = m [f] ,! e && q! == g.origType || c && c.guid! == g.guid || h &&! h.test (g.namespace) || d && d! == g.selector && ("**"! == d ||! g.selector) | | (m.splice (f, 1), g.selector && m.delegateCount -, l.remove && l.remove.call (a, g)); i &&! m.length && (l.teardown && l.teardown.call (a, p , r.handle)! ==! 1 || n.removeEvent (a, o, r.handle), eliminar k [o])} else for (o en k) n.event.remove (a, o + b [j], c, d,! 0); n.isEmptyObject (k) && (eliminar r.handle, n._removeData (a, "eventos"))}}, trigger: function (b, c, d, e ) {var f, g, h, i, k, l, m, o = [d || z], p = j.call (b, "tipo")? b.type: b, q = j.call (b, "espacio de nombres")? b.namespace.split ("."): []; if (h = l = d = d || z, 3! == d.nodeType && 8! == d.nodeType &&! _ .test (p + n.event.triggered) && (p.indexOf (".")> = 0 && (q = p.split ("."), p = q.shift (), q.sort ()) , g = p.indexOf (": ") <0 &&" en "+ p, b = b [n.expando]? B: new n.Event (p," objeto "== tipo de b && b), b.isTrigger = e? 2: 3, b. namespace = q.join ("."), b.namespace_re = b.namespace? new RegExp ("(^ | \\.)" + q.join ("\\. (?:. * \\. |) ") +" (\\. | $) "): null, b.result = void 0, b.target || (b.target = d), c = null == c? [b]: n.makeArray (c, [b]), k = n.event.special [p] || {}, e ||! k.trigger || k.trigger.apply (d, c)! ==! 1)) { if (! e &&! k.noBubble &&! n.isWindow (d)) {para (i = k.delegateType || p, _. test (i + p) || (h = h.parentNode); h; h = h.parentNode) o.push (h), l = h; l === (d.ownerDocument || z) && o.push (l.defaultView || l.parentWindow || a)} m = 0; while (h = o [m ++]) &&! b.isPropagationStopped ()) b.type = m> 1? i: k.bindType || p, f = (n._data (h, "eventos") || {} ) [tipo b] && n._data (h, "manejar"), f && f.apply (h, c), f = g && h [g], f && f.aplique && n.acceptData (h) && (b.result = f.apply (h, c), b.result ===! 1 && b.preventDefault ()); if (b.type = p,! e&&! b.isDefaultPrevented ( ) && (! k._default || k._default.apply (o.pop (), c) ===! 1) && n.acceptData (d) && g && d [p] &&! n.isWindow (d)) {l = d [g], l && (d [g] = nulo), n.event.triggered = p; intente {d [p] ()} catch (r) {} n.event.triggered = void 0, l && ( d [g] = l)} return b.result}}, dispatch: function (a) {a = n.event.fix (a); var b, c, e, f, g, h = [], i = d.call (argumentos), j = (n._data (esto, "eventos") || {}) [a.type] || [], k = n.event.special [a.type] || {}; if (i [0] = a, a.delegateTarget = this,! k.preDispatch || k.preDispatch.call (this, a)! ==! 1) {h = n.event.handlers.call (esto, a, j), b = 0; while ((f = h [b ++]) &&! a.isPropagationStopped ()) {a.currentTarget = f.elem, g = 0; while ((e = f. manejadores [g ++]) &&! a.isImmediatePropagationStopped ()) (! a.namespace_re || a.namespace_re.test (e.namespace)) && (a.handleObj = e, a.data = e.data, c = ((n.event.special [e.origType] || {}). handle || e.handler) .apply (f.elem, i), void 0! == c && (a.result = c) ===! 1 && (a.preventDefault (), a.stopPropagation ()))) return k.postDispatch && k.postDispatch.call (this, a), a.result}}, handlers: function (a, b) {var c, d, e, f, g = [], h = b.delegateCount, i = a.target; if (h && i.nodeType && (! a.button || "click"! == a.type)) para (; i! = this; i = i.parentNode || this) if (1 == = i.nodeType && (i.disabled! ==! 0 || "click"! == a.type)) {para (e = [], f = 0; h> f; f ++) d = b [f] , c = d.selector + "", void 0 === e [c] && (e [c] = d.needsContext? n (c, this) .index (i)> = 0: n.find (c, this, null, [i]). length), e [c] && e.push (d); e.length && g.push ({elem: i, handlers: e})} return h <b.length && g.push ({ Elem: esto, manejadores: b.slice (h)}), g}, fix: function (a) {if (a [n.expando]) devuelve a; var b, c, d, e = a.type, f = a, g = this. fixHooks [e]; g || (this.fixHooks [e] = g = $. test (e)? this.mouseHooks: Z.test (e)? this.keyHooks: {}), d = g.props? this.props.concat (g.props): this.props, a = new n.Event (f), b = d.length; mientras que (b -) c = d [b], a [c] = f [c]; return a.target || (a.target = f.srcElement || z), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey = !! a.metaKey, g.filter? g.filter (a, f): a}, props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shift target timeStamp ver" .split (""), fixHooks: {}, keyHooks : {propiedades: "char charCode key keyCode" .split (""), filter: function (a, b) {return null == a.which && (a.which = null! = b.charCode? b.charCode: b .keyCode), a}}, mouseHooks: {props: "botón botones clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement ".split (" "), filter: function (a, b) {var c, d, e, f = b.button, g = b.fromElement; devolver nulo == a.pageX && null! = b.clientX && (d = a.target.ownerDocument || z, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e && e.scrollLeft || c &cr.spollLeft || 0) - (e && e.clientLeft || c && c.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.crientTop || 0) | 0)) ,! a.relatedTarget && g && (a.relatedTarget = g === a.target?b.toElement:g ),a.which||void 0 === f || (a.which = 1 & f? 1 : 2 & f? 3: 4 & f? 2: 0), a}}, special: {load: {noBubble:! 0}, focus: {trigger: function () {if (this! == db () && this.focus) intente {return this.focus () ,! 1} catch (a) {}}, delegateType: "focusin"}, desenfoque:{trigger: function () {return this === db () && this.blur? (this.blur () ,! 1): void 0}, delegateType: "focusout"}, haga clic en: {trigger: function () { return n.nodeName (this, "input") && "checkbox" === this.type && this.click? (this.click () ,! 1): void 0}, _ default: function (a) {return n.nodeName (a.target, "a")}}, antes de descargar: {postDispatch: function (a) {void 0! == a.result && (a.originalEvent.returnValue = a.result)}}}, simulate: function (a , b, c, d) {var e = n.extendido (nuevo n.Event, c, {tipo: a, isSimulated:! 0, originalEvent: {}}); d? n.event.trigger (e, null , b): n.event.dispatch.call (b, e), e.isDefaultPrevented () && c.preventDefault ()}}, n.removeEvent = z.removeEventListener? function (a, b, c) {a.removeEventListener && a .removeEventListener (b, c,! 1)}: function (a, b, c) {var d = "on" + b; a.detachEvent && (typeof a [d] === L &&(a [d] = nulo), a.detachEvent (d, c))}, n.Event = function (a, b) {devuelve este ejemplo de n.Event? (a && a.type? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && (a.returnValue ===! 1 || a.getPreventDefault && a.getPreventDefault ())? bb: cb) this.type = a, b && n.extendente (this, b), this.timeStamp = a && a.timeStamp || n.now (), void (this [n.expando] =! 0)): new n.Event (a , b)}, n.Event.prototype = {isDefaultPrevented: cb, isPropagationStopped: cb, isImmediatePropagationStopped: cb, preventDefault: function () {var a = this.originalEvent; this.isDefaultPrevented = bb, p & a e. .preventDefault (): a.returnValue =! 1)}, stopPropagation: function () {var a = this.originalEvent; this.isPropagationStopped = bb, a && (a.stopPropagation && a.stopPropagation (), a.cancelBubble =!) }stopImmediatePropagation: function () {this.isImmediatePropagationStopped = bb, this.stopPropagation ()}}, n.each ({mouseenter: "mouseover", mouseleave: "mouseout"), function (a, b) {n.event.special [a] = {delegateType: b, bindType: b, handle: function (a) {var c, d = this, e = a.relatedTarget, f = a.handleObj; return (! e || e! == d && ! n.contains (d, e)) && (a.type = f.origType, c = f.handler.apply (this, argumentos), a.type = b), c}}}), l.submitBubbles | | (n.event.special.submit = {setup: function () {return n.nodeName (this, "form") ?! 1: void n.event.add (this, "click._submit keypress._submit", función (a) {var b = a. objetivo, c = n.nodoNombre (b, "entrada") || n.nodoNombre (b, "botón")? b.form: void 0; c &&! n._data ( c, "submitBubbles") && (n.event.add (c, "submit._submit", función (a) {a._submit_bubble =! 0}), n._data (c, "submitBubbles ",! 0))})}, postDispatch: function (a) {a._submit_bubble && (elimine a._submit_bubble, this.parentNode &&! a.isTrigger && n.event.simulate (" submit ", this.parentNode, a,!! 0))}, teardown: function () {return n.nodeName (this, "form") ?! 1: void n.event.remove (this, "._ submit")}}), l.changeBubbles || ( n.event.special.change = {setup: function () {return Y.test (this.nodeName)? (("checkbox" === this.type || "radio" === this.type) && ( n.event.add (esto, "propertychange._change", función (a) {"check" === a.originalEvent.propertyName && (this._just_changed =! 0)}), n.event.add (this, " click._change ", función (a) {this._just_changed &&! a.isTrigger && (this._just_changed =! 1), n.event.simulate (" change ", this, a,! 0)})), 1 1 : void n.event.add (esto, "beforeactivate._change ", function (a) {var b = a.target; Y.test (b.nodeName) &&! n._data (b," changeBubbles ") && (n.event.add (b," change. _change ", función (a) {! this.parentNode || a.isSimulated || a.isTrigger || n.event.simulate (" change ", this.parentNode, a,! 0)}), n._data ( b, "changeBubbles",! 0))})}, handle: function (a) {var b = a.target; devuelve esto! == b || a.isSimulated || a.isTrigger || "radio"! == b.type && "checkbox"! == b.type? a.handleObj.handler.apply (this, argumentos): void 0}, teardown: function () {return n.event.remove (this, "._ change "),! Y.test (this.nodeName)}}), l.focusinBubbles || n.each ({focus:" focusin ", blur:" focusout "}, function (a, b) {var c = function (a) {n.event.simulate (b, a.target, n.event.fix (a) ,! 0)}; n.event.special [b] = {setup: function () {var d = this .ownerDocument || esto, e = n._data (d, b); e || d.addEventListener (a, c,! 0), n._data (d, b, (e || 0) +1)}, teardown: function () {var d = this.ownerDocument || this, e = n._data (d, b) -1; e? n._data (d, b, e) :( d.removeEventListener (a, c,! 0), n._removeData ( d, b))}}}), n.fn.extend ({on: function (a, b, c, d, e) {var f, g; if ("object" == typeof a) {"string "! = typeof b && (c = c || b, b = void 0); para (f in a) this.on (f, b, c, a [f], e); devuelva esto} if (null = = c && null == d? (d = b, c = b = void 0): null == d && ("string" == typeof b? (d = c, c = void 0) :( d = c, c = b, b = void 0)), d ===! 1) d = cb; de lo contrario si (! d) devuelve esto; return 1 === e && (g = d, d = función (a) {return n ( ) .off (a), g.apply (this, argumentos)}, d.guid = g.guid || (g.guid = n.guid ++)), this.each (function () {n.event.add (esto, a, d, c, b)})}, one: function (a, b, c, d) {return this.on (a, b, c, d, 1)}, off: function (a , b, c) {var d, e; if (a && a.preventDefault && a.handleObj) devuelve d = a.handleObj, n (a.delegateTarget) .off (d.namespace? d.origType + "." + d.namespace: d.origType, d.selector, d.handler), this; if ("object" == typeof a ) {para (e en a) this.off (e, b, a [e]); return this} return (b ===! 1 || "function" == typeof b) && (c = b, b = void 0), c ===! 1 && (c = cb), this.each (function () {n.event.remove (this, a, c, b)})}, trigger: function (a, b ) {return this.each (function () {n.event.trigger (a, b, this)})}, triggerHandler: function (a, b) {var c = this [0]; return c? n.event .trigger (a, b, c,! 0): void 0}}); función eb (a) {var b = fb.split ("|"), c = a.createDocumentFragment (); if (c.createElement ) while (b.length) c.createElement (b.pop ()); return c} var fb = "abbr | artículo | aparte | audio | bdi | lienzo | datos | datalist | detalles | figcaption | figura | pie de página | encabezado | hgroup | marca | metro | nav | salida | progreso | sección | resumen | tiempo | video ", gb = / jQuery \ d + =" (?:nulo | \ d +) "/ g, hb = new RegExp (" <(?: "+ fb +") [\\ s />] "," i "), ib = / ^ \ s + /, jb = / < (? | area | br | col | embed | hr | img | input | link | meta | param) (([\ w:] +) [^>] *) \ /> / gi, kb = / <([ \ w:] +) /, lb = / <tbody / i, mb = / <| & #? \ w +; /, nb = / <(?: script | style | link) / i, ob = / checked \ s * (?: [^ =] | = \ s * .checked.) / i, pb = / ^ $ | \ / (?: java | ecma) script / i, qb = / ^ true \ / (. * ) /, rb = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g, sb = {opción: [ 1, "<select multiple = 'multiple'>", "</select>"], leyenda: [1, "<fieldset>", "</fieldset>"], area: [1, "<map>" , "</map>"], param: [1, "<object>", "</object>"], thead: [1, "<table>", "</table>"], tr: [ 2, "<table> <tbody>", "</tbody> </table>"],col: [2, "<table> <tbody> </tbody> <colgroup>", "</colgroup> </table>"], td: [3, "<table> <tbody> <tr>", "</tr> </tbody> </table>"], _ default: l.htmlSerialize? [0, "", ""]: [1, "X <div>", "</div>"]} , tb = eb (z), ub = tb.appendChild (z.createElement ("div")); sb.optgroup = sb.option, sb.tbody = sb.tfoot = sb.colgroup = sb.caption = sb. thead, sb.th = sb.td; función vb (a, b) {var c, d, e = 0, f = typeof a.getElementsByTagName! == L? a.getElementsByTagName (b || "*"): typeof a.querySelectorAll! == L? a.querySelectorAll (b || "*"): void 0; if (! f) for (f = [], c = a.childNodes || a; null! = (d = c [e]); e ++)! b || n.nodoNombre (d, b)? f.push (d): n.merge (f, vb (d, b)); devolver void 0 === b || b && n.nodoNombre (a, b)? n.merge ([a], f): f} function wb (a) {X.test (a.type) && (a.defaultChecked = a.checked)} function xb (a, b) {return n.nodeName (a, "table") && n.nodeName (11! == b.nodeType? b: b.firstChild, "tr")? a.getElementsByTagName ("tbody") [0] || a.appendChild (a.ownerDocument.createElement ("tbody")): a} function yb (a) {return a.type = (null! == n.find.attr (a, "type")) + "/" + a.type, a} function zb (a) {var b = qb.exec (a.type); return b? a.type = b [1]: a.removeAttribute ("type"), a} función Ab (a, b) {for (var c, d = 0; null! = (c = a [d]); d ++) n. _data (c, "globalEval",! b || n._data (b [d], "globalEval"))} función Bb (a, b) {if (1 === b.nodeType && n.hasData (a)) {var c, d, e, f = n._data (a), g = n._data (b, f), h = f.eventos; si (h) {borrar g.handle, g.events = {} ; para (c en h) para (d = 0, e = h [c] .length; e> d; d ++) n.event.add (b, c, h [c] [d])} g.data && (g.data = n.extendente ({}, g.datos))}} función Cb (a, b) {var c, d, e; if (1 === b.nodeType) {if (c = b.nodeName.toLowerCase () ,! l.noCloneEvent && b [n. expando]) {e = n._data (b); para (d en e.eventos) n.removeEvent (b, d, e.handle); b.removeAttribute (n.expando)} "script" === c && b .text! == a.text? (yb (b) .text = a.text, zb (b)): "object" === c? (b.parentNode && (b.outerHTML = a.outerHTML), l .html5Clone && a.innerHTML &&! n.trim (b.innerHTML) && (b.innerHTML = a.innerHTML)): "input" === c && X.test (a.type)? (b.defaultChecked = b.checked = a .checked, b.value! == a.value && (b.value = a.value)): "option" === c? b.defaultSelected = b.selected = a.defaultSelected :( "input" === c || "área de texto" === c) && (b.defaultValue = a.defaultValue)}} n.extextend ({clone: ​​function (a, b, c) {var d, e, f, g, h, i = n.contains (a.ownerDocument, a); if (l.html5Clone || n.isXMLDoc (a) ||!hb.test ("<" + a.nodeName + ">")? f = a.cloneNode (! 0) :( ub.innerHTML = a.outerHTML, ub.removeChild (f = ub.firstChild)),! (l .noCloneEvent && l.noCloneChecked || 1! == a.nodeType && 11! == a.nodeType || n.isXMLDoc (a))) para (d = vb (f), h = vb (a), g = 0; null ! = (e = h [g]); ++ g) d [g] && Cb (e, d [g]); if (b) if (c) para (h = h || vb (a), d = d || vb (f), g = 0; null! = (e = h [g]); g ++) Bb (e, d [g]); de lo contrario Bb (a, f); return d = vb ( f, "script"), d.length> 0 && Ab (d,! i && vb (a, "script")), d = h = e = null, f}, buildFragment: function (a, b, c, d) { para (var e, f, g, h, i, j, k, m = a.length, o = eb (b), p = [], q = 0; m> q; q ++) si (f = a [q], f || 0 === f) if ("object" === n.type (f)) n.merge (p, f.nodeType? [f]: f); else if (mb. test (f)) {h = h || o.appendChild (b.createElement ("div")), i = (kb.exec (f) || ["", ""]) [1] .toLowerCase ( ), k = sb [i] || sb._default, h.innerHTML = k [1] + f.replace (jb,"<$ 1> </ $ 2>") + k [2], e = k [0]; mientras que (e -) h = h .Agregar niño; si (! L.leadingWhitespace && ib.test (f) && p.push ( b.createTextNode (ib.exec (f) [0])) ,! l.tbody) {f = "table"! == i || lb.test (f)? "<table>"! == k [ 1] || lb.test (f)? 0: h: h.firstChild, e = f && f.childNodes.length; while (e -) n.nodeName (j = f.childNodes [e], "tbody") &&! j.childNodes.length && f.removeChild (j)} n.merge (p, h.childNodes), h.textContent = ""; while (h.firstChild) h.removeChild (h.firstChild); h = o. lastChild} else p.push (b.createTextNode (f)); h && o.removeChild (h), l.appendChecked || n.grep (vb (p, "input"), wb), q = 0; while (f = p [q ​​++]) si ((! d || -1 === n.inArray (f, d)) && (g = n.contains (f.ownerDocument, f), h = vb (o.appendChild ( f), "script"), g && Ab (h), c)) {e = 0; while (f = h [e ++]) pb.test (f.type || "") && c.push (f)} return h = null, o}, cleanData: function (a, b) {for (var d, e, f, g, h = 0, i = n.expando, j = n.cache, k = l.deleteExpando, m = n.event.special; null! = (d = a [h]); h ++) if ((b || n.acceptData (d)) && (f = d [i], g = f && j [f])) {if (g.events) para (e in g.events) m [e]? n.event.remove (d, e): n.removeEvent (d, e, g.handle) ; j [f] && (eliminar j [f], k? borrar d [i]: tipo de d.removeAttribute! == L? d.removeAttribute (i): d [i] = null, c.push (f) )}}}), n.fn.extend ({text: function (a) {return W (this, function (a) {return void 0 === a? n.text (this): this.empty () .append ((este [0] && este [0] .ownerDocument || z) .createTextNode (a))}, nulo, a, argumentos.length)}, append: function () {return this.domManip (argumentos, función (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = xb (this, a); b.appendChild (a)} })}, prepend: function () {return this.domManip (argumentos, function (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = xb (this, a); b.insertBefore (a, b.firstChild)}})}, before: function () {return this.domManip (argumentos, function (a) {this.parentNode && this.parentNode.insertBefore (a, this)})}, after: function () {return this.domManip (argumentos, function (a) {this.parentNode && this.parentNode.insertBefore (a, this .nextSibling)})}, remove: function (a, b) {for (var c, d = a? n.filter (a, esto): esto, e = 0; null! = (c = d [e] ); e ++) b || 1! == c.nodeType || n.cleanData (vb (c)), c.parentNode && (b && n.contains (c.ownerDocument, c) && Ab (vb (c, "script") ), c.parentNode.removeChild (c)); devuelva esto}, empty: function () {for (var a, b = 0; null! = (a = this [b]); b ++) {1 === a.nodeType && n.cleanData (vb (a,! 1)); while (a.firstChild) a.removeChild (a.firstChild); a.options && n.nodeName (a, "select") && (a.options.length = 0)} devolver esto}, clonarfunción (a, b) {return a = null == a?! 1: a, b = null == b? a: b, this.map (function () {return n.clone (this, a, b) })}, html: function (a) {return W (this, function (a) {var b = this [0] || {}, c = 0, d = this.length; if (void 0 === a) devuelve 1 === b.nodeType? b.innerHTML.replace (gb, ""): void 0; if (! ("string"! = typeof a || nb.test (a) ||! l. htmlSerialize && hb.test (a) ||! l.leadingWhitespace && ib.test (a) || sb [(kb.exec (a) || ["", ""])) [1] .toLowerCase ()))) {a = a.replace (jb, "<$ 1> </ $ 2>"); intente {para (; d> c; c ++) b = esto [c] || {}, 1 === b.nodeType && (n. cleanData (vb (b,! 1)), b.innerHTML = a); b = 0} catch (e) {}} b && this.empty (). append (a)}, null, a, argument.length)} , replaceWith: function () {var a = argumentos [0]; devolver this.domManip (argumentos, function (b) {a = this.parentNode, n.cleanData (vb (this)), a && a.replaceChild (b, this )}), a && (a.length || a.nodeType)? this: this.remove ()}, detach: function (a) {return this.remove (a,! 0)}, domManip: function (a, b) {a = e.apply ([], a ); var c, d, f, g, h, i, j = 0, k = this.length, m = this, o = k-1, p = a [0], q = n.isFunction (p) ; if (q || k> 1 && "string" == tipo de p &&! l.checkClone && ob.test (p)) devuelva este.each (función (c) {var d = m.eq (c); q && (a [ 0] = p.call (this, c, d.html ())), d.domManip (a, b)}); if (k && (i = n.buildFragment (a, this [0] .ownerDocument ,! 1, esto), c = i.firstChild, 1 === i.childNodes.length && (i = c), c)) {para (g = n.map (vb (i, "script"), yb), f = g.length; k> j; j ++) d = i, j! == o && (d = n.clone (d,! 0,! 0), f && n.merge (g, vb (d, "script" ))), b.call (este [j], d, j); si (f) para (h = g [g.length-1] .ownerDocument, n.map (g, zb), j = 0; f> j; j ++) d = g [j], pb.test (d.type || "") &&! n._data (d, "globalEval") && n.contains (h, d) &&(d.src? n._evalUrl && n._evalUrl (d.src): n.globalEval ((d.text || d.textContent || d.innerHTML || ""). replace (rb, ""))); i = c = null} devolver esto}}), n.each ({appendTo: "append", prependTo: "prepend", insertBefore: "before", insertAfter: "after", replaceAll: "replaceWith"}, function ( a, b) {n.fn [a] = función (a) {para (var c, d = 0, e = [], g = n (a), h = g.length-1; h> = d ; d ++) c = d === h? this: this.clone (! 0), n (g [d]) [b] (c), f.apply (e, c.get ()); devuélvalo .pushStack (e)}}); var Db, Eb = {}; función Fb (b, c) {var d = n (c.createElement (b)). appendTo (c.body), e = a.getDefaultComputedStyle ? a.getDefaultComputedStyle (d [0]). display: n.css (d [0], "display"); return d.detach (), e} función Gb (a) {var b = z, c = Eb [a]; devolver c || (c = Fb (a, b), "none"! == c && c || (Db = (Db || n ("<iframe frameborder = '0' width = '0' height = '0 '/> ")). AppendTo (b.documentElement), b = (Db [0] .contentWindow || Db [0] .contentDocument) .document, b.write (), b.close (), c = Fb (a, b), Db.detach ()), Eb [a] = c), c} function () {var a, b, c = z.createElement ("div"), d = "- webkit tamaño de la caja: cuadro de contenido; cuadro de tamaño de la caja de contenido: cuadro de tamaño de caja de contenido cuadro de contenido; pantalla: bloque; relleno: 0; margen: 0; borde: 0 "; c.innerHTML =" <link/><table> </table> <a href='/a'> a </a> <input type = 'checkbox' /> ", a = c.getElementsByTagName (" a ") [0], a.style.cssText = "float: left; opacity: .5", l.opacity = / ^ 0.5 / .test (a.style.opacity), l.cssFloat = !! a.style.cssFloat, c.style .backgroundClip = "content-box", c.cloneNode (! 0) .style.backgroundClip = "", l.clearCloneStyle = "content-box" === c.style.backgroundClip, a = c = null, l.shrinkWrapBlocks = function () {var a, c, e, f; if (null == b) {if (a = z.getElementsByTagName ("body") [0] ,! a) return; f = "border: 0 ; ancho: 0; altura: 0; posición: absoluta; superior: 0; izquierda: -9999px ", c = z.createElement (" div "), e = z.createElement (" div "), a.appendChild (c ) .appendChild (e), b =! 1, tipo de e.style.zoom! == L && (e.style.cssText = d + "; ancho: 1px; relleno: 1px; zoom: 1", e.innerHTML = " <div> </div> ", e.firstChild.style.width =" 5px ", b = 3! == e.offsetWidth), a.removeChild (c), a = c = e = null} return b} } (); var Hb = / ^ margen /, Ib = nuevo RegExp ("^ (" + T + ") (?! px) [az%] + $", "i"), Jb, Kb, Lb = / ^ (arriba | derecha | abajo | izquierda) $ /; a.getComputedStyle? (Jb = function (a) {return a.ownerDocument.defaultView.getComputedStyle (a, null)}, Kb = function (a, b, c) {var d, e, f, g, h = a.style; return c = c || Jb (a), g = c? c.getPropertyValue (b) || c [b]:void 0, c && (""! == g || n.contains (a.ownerDocument, a) || (g = n.style (a, b)), Ib.test (g) && Hb.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g? g: g + ""}): z.documentElement.currentStyle && (Jb = function (a) {return a.currentStyle}, Kb = function (a, b, c) {var d, e, f, g, h = a.style; devolver c = c || Jb (a), g = c? c [b]: void 0, null == g && h && h [b] && (g = h [b]), Ib.test (g) &&! Lb.test (b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), h.left = "fontSize" === b? "1em": g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), void 0 === g? g: g + "" || "auto"}); function Mb (a, b) {return {get: function () {var c = a (); if (null! = c) devolver c? void eliminar this.get: (this.get = b) .apply (this, argumentos)}}}! function () {var b, c, d, e, f, g, h = z.createElement ("div"), i = "border: 0; ancho: 0; altura: 0; posición: absoluta; superior: 0; izquierda: -9999px ", j =" - tamaño de caja de kit de webs: cuadro de contenido; cuadro de tamaño de caja de contenido: cuadro de tamaño de caja de contenido : cuadro de contenido; pantalla: bloque; relleno: 0; margen: 0; borde: 0 "; h.innerHTML =" <link/><table> </table> <a href='/a'> a </ a> <input type = 'checkbox' /> ", b = h.getElementsByTagName (" a ") [0], b.style.cssText =" float: left; opacity: .5 ", l.opacity = / ^ 0.5 / .test (b.style.opacity), l.cssFloat = !! b.style.cssFloat, h.style.backgroundClip = "content-box", h.cloneNode (! 0) .style.backgroundClip = "" , l.clearCloneStyle = "content-box" === h.style.backgroundClip, b = h = null, n.extextend (l, {reliableHiddenOffsets: function () {if (null! = c) return c; var a ,segundo,d, e = z.createElement ("div"), f = z.getElementsByTagName ("body") [0]; if (f) return e.setAttribute ("className", "t"), e.innerHTML = " <link/><table> </table> <a href='/a'> a </a> <input type = 'checkbox' /> ", a = z.createElement (" div "), a.style .cssText = i, f.appendChild (a) .appendChild (e), e.innerHTML = "<table> <tr> <td> </td> <td> t </td> </tr> </ table > ", b = e.getElementsByTagName (" td "), b [0] .style.cssText =" relleno: 0; margen: 0; borde: 0; pantalla: ninguno ", d = 0 === b [0 ] .offsetHeight, b [0] .style.display = "", b [1] .style.display = "none", c = d && 0 === b [0] .offsetHeight, f.removeChild (a), e = f = nulo, c}, boxSizing: function () {return null == d && k (), d}, boxSizingReliable: function () {return null == e && k (), e}, pixelPosition: function () {return null == f && k (), f}, reliableMarginRight: function () {var b, c, d, e; if (null == g && a.getComputedStyle) {if (b = z.getElementsByTagName ("body") [0] ,! b) return; c = z.createElement ("div"), d = z.createElement ("div"), c.style.cssText = i, b.appendChild (c) .appendChild (d), e = d.appendChild (z.createElement ("div")), e.style.cssText = d.style.cssText = j, e.style.marginRight = e. style.width = "0", d.style.width = "1px", g =! parseFloat ((a.getComputedStyle (e, null) || {}). marginRight), b.removeChild (c)} devolver g }}); función k () {var b, c, h = z.getElementsByTagName ("body") [0]; h && (b = z.createElement ("div"), c = z.createElement ("div" ), b.style.cssText = i, h.appendChild (b) .appendChild (c), c.style.cssText = "- webkit-box-sizing: border-box; -moz-box-sizing: border-box ;tamaño de caja: borde-caja; posición: absoluta; pantalla: bloque; relleno: 1px; borde: 1px; ancho: 4px; margen superior: 1%; superior: 1% ", n.swap (h, null! = h.style.zoom? {zoom: 1}: {}, function () {d = 4 === c.offsetWidth}), e =! 0, f =! 1, g =! 0, a.getComputedStyle && ( f = "1%"! == (a.getComputedStyle (c, null) || {}). top, e = "4px" === (a.getComputedStyle (c, null) || {width: "4px "}). ancho), h.removeChild (b), c = h = null)}} (), n.swap = function (a, b, c, d) {var e, f, g = {}; para (f en b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []); para (f in b ) a.style [f] = g [f]; return e}; var Nb = / alpha \ ([^)] * \) / i, Ob = / opacity \ s * = \ s * ([^)] *) /, Pb = / ^ (ninguno | tabla (?! - c [ea]). +) /, Qb = nuevo RegExp ("^ (" + T + ") (. *) $", "I") , Rb = nuevo RegExp ("^ ([+ -]) = (" + T + ")", "i"), Sb = {posición: "absoluta", visibilidad: "oculta", pantalla: "bloque"}, Tb = {letterSpacing:0, fontWeight: 400}, Ub = ["Webkit", "O", "Moz", "ms"]; función Vb (a, b) {if (b en a) return b; var c = b.charAt (0) .toUpperCase () + b.slice (1), d = b, e = Ub.length; mientras que (e -) if (b = Ub [e] + c, b en a) return b; return d} función Wb (a, b) {para (var c, d, e, f = [], g = 0, h = a.length; h> g; g ++) d = a [g], d.style && (f [g] = n._data (d, "olddisplay"), c = d.style.display, b? (f [g] || "none"! == c || (d.style.display = ""), "" === d.style.display && V (d) && (f [g] = n._data (d, "olddisplay", Gb (d.nodeName)))): f [g] || (e = V (d), (c && "none"! == c ||! e) && n._data (d, "olddisplay", e? c: n.css (d, "display")))); para (g = 0; h> g; g ++) d = a [g], d.style && (b && "none"! == d.style.display && ""! == d.style.display || (d. style.display = b? f [g] || "": "ninguna ")); retorna a} función Xb (a, b, c) {var d = Qb.exec (b); devuelve d? Math.max (0, d [1] - (c || 0)) + (d [2] || "px"): b} función Yb (a, b, c, d, e) {para (var f = c === (d? "borde": "contenido")? 4 : "ancho" === b? 1: 0, g = 0; 4> f; f + = 2) "margen" === c && (g + = n.css (a, c + U [f] ,! 0 , e)), d? ("contenido" === c && (g- = n.css (a, "relleno" + U [f] ,! 0, e)), "margen"! == c && (g - = n.css (a, "borde" + U [f] + "Ancho",! 0, e))) :( g + = n.css (a, "relleno" + U [f] ,! 0, e), "relleno"! == c && (g + = n.css (a, "borde" + U [f] + "Ancho",! 0, e))); return g} función Zb (a, b, c) {var d =! 0, e = "ancho" === b? a.offsetWidth: a.offsetHeight, f = Jb (a), g = l.boxSizing () && "border-box" === n.css (a, "boxSizing",! 1, f); if (0> = e || null == e) {if (e = Kb (a, b, f), (0> e || null == e) &&(e = a.style [b]), Ib.test (e)) devuelve e; d = g && (l.boxSizingReliable () || e === a.style [b]), e = parseFloat (e) || 0} devolver e + Yb (a, b, c || (g? "Borde": "contenido"), d, f) + "px"} n.extextend ({cssHooks: {opacity: {obtener: función (a, b) {si (b) {var c = Kb (a, "opacidad"); return "" === c? "1": c}}}}, cssNumber: {columnCount:! 0, fillOpacity:! 0, fontWeight:! 0, lineHeight:! 0, opacity:! 0, order:! 0, orphans:! 0, widows:! 0, zIndex:! 0, zoom:! 0}, cssProps: {" float ": l.cssFloat?" cssFloat ":" styleFloat "}, style: function (a, b, c, d) {if (a && 3! == a.nodeType && 8! == a.nodeType && a.style) {var e , f, g, h = n.camelCase (b), i = a.style; if (b = n.cssProps [h] || (n.cssProps [h] = Vb (i, h)), g = n.cssHooks [b] || n.cssHooks [h], void 0 === c) devuelve g && "get" en g && void 0! == (e = g.get (a,! 1, d))? e : i [b]; if (f = typeof c, "cadena "=== f && (e = Rb.exec (c)) && (c = (e [1] +1) * e [2] + parseFloat (n.css (a, b)), f =" número "), null! = c && c === c && (" number "! == f || n.cssNumber [h] || (c + =" px "), l.clearCloneStyle ||" "! == c || 0! == b.indexOf ("background") || (i [b] = "inherit"),! (G && "set" en g && void 0 === (c = g.set (a, c, d) )))) intente {i [b] = "", i [b] = c} catch (j) {}}}, css: function (a, b, c, d) {var e, f, g, h = n.camelCase (b); return b = n.cssProps [h] || (n.cssProps [h] = Vb (a.style, h)), g = n.cssHooks [b] || n. cssHooks [h], g && "obtener" en g && (f = g.get (a,! 0, c)), void 0 === f && (f = Kb (a, b, d)), "normal" = == f && b en Tb && (f = Tb [b]), "" === c || c? (e = parseFloat (f), c ===! 0 || n.isNumeric (e)? e || 0: f): f}}), n.each (["altura", "ancho"], función (a, b) {n.cssHooks [b] = {obtener:función (a, c, d) {return c? 0 === a.offsetWidth && Pb.test (n.css (a, "display"))? n.swsw (a, Sb, function () {return Zb (a , b, d)}): Zb (a, b, d): void 0}, set: function (a, c, d) {var e = d && Jb (a); devolver Xb (a, c, d? Yb (a, b, d, l.boxSizing () && "border-box" === n.css (a, "boxSizing",! 1, e), e): 0)}}}), l.opacity || (n.cssHooks.opacity = {get: function (a, b) {return Ob.test ((b && a.currentStyle? a.currentStyle.filter: a.style.filter) || "")? 01 * parseFloat (RegExp. $ 1) + "": b? "1": ""}, set: function (a, b) {var c = a.style, d = a.currentStyle, e = n.isNumeric (b) ? "alpha (opacidad =" + 100 * b + ")": ", f = d && d.filter || c.filter ||" "; c.zoom = 1, (b> = 1 ||" "== = b) && "" === n.trim (f.replace (Nb, "")) && c.removeAttribute && (c.removeAttribute ("filtro ")," "=== b || d &&! d.filter) || (c.filter = Nb.test (f)? f.replace (Nb, e): f +" "+ e)}}) , n.cssHooks.marginRight = Mb (l.reliableMarginRight, función (a, b) {return b? n.swsw (a, {display: "inline-block"}, Kb, [a, "marginRight"]): void 0}), n.each ({margin: "", padding: "", border: "Width"}, function (a, b) {n.cssHooks [a + b] = {expand: function (c) {para (var d = 0, e = {}, f = "cadena" == tipo de c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; return e}}, Hb.test (a) || (n.cssHooks [a + b] .set = Xb)} ), n.fn.extend ({css: function (a, b) {return W (this, function (a, b, c) {var d, e, f = {}, g = 0; if (n. isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d ); return f} return void 0! == c? n.style (a, b, c): n.css (a, b)f + "" + e)}}), n.cssHooks.marginRight = Mb (l.reliableMarginRight, función (a, b) {return b? n.swsw (a, {display: "inline-block"}, Kb, [a, "marginRight"]): void 0}), n.each ({margin: "", padding: "", border: "Width"}, function (a, b) {n.cssHooks [a + b ] = {expand: function (c) {for (var d = 0, e = {}, f = "string" == typeof c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; return e}}, Hb.test (a) || (n.cssHooks [a + b] .set = Xb)}), n.fn.extend ({css: function (a, b) {return W (this, function (a, b, c) {var d, e, f = {} , g = 0; if (n.isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g], 1, d); return f} return void 0! == c? n.style (a, b, c): n.css (a, b)f + "" + e)}}), n.cssHooks.marginRight = Mb (l.reliableMarginRight, función (a, b) {return b? n.swsw (a, {display: "inline-block"}, Kb, [a, "marginRight"]): void 0}), n.each ({margin: "", padding: "", border: "Width"}, function (a, b) {n.cssHooks [a + b ] = {expand: function (c) {for (var d = 0, e = {}, f = "string" == typeof c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; return e}}, Hb.test (a) || (n.cssHooks [a + b] .set = Xb)}), n.fn.extend ({css: function (a, b) {return W (this, function (a, b, c) {var d, e, f = {} , g = 0; if (n.isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g], 1, d); return f} return void 0! == c? n.style (a, b, c): n.css (a, b)cada ({margen: "", relleno: "", borde: "Ancho"}, función (a, b) {n.cssHooks [a + b] = {expand: function (c) {for (var d = 0 , e = {}, f = "cadena" == tipo de c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; return e}}, Hb.test (a) || (n.cssHooks [a + b] .set = Xb)}), n.fn.extend ({css: function (a, b) {return W (this, function (a, b, c) {var d, e, f = {}, g = 0; if (n.isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); return f} return void 0! == c? N.style (a, b, c): n.css (a, b)cada ({margen: "", relleno: "", borde: "Ancho"}, función (a, b) {n.cssHooks [a + b] = {expand: function (c) {for (var d = 0 , e = {}, f = "cadena" == tipo de c? c.split (""): [c]; 4> d; d ++) e [a + U [d] + b] = f [d] || f [d-2] || f [0]; return e}}, Hb.test (a) || (n.cssHooks [a + b] .set = Xb)}), n.fn.extend ({css: function (a, b) {return W (this, function (a, b, c) {var d, e, f = {}, g = 0; if (n.isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g] ,! 1, d); return f} return void 0! == c? N.style (a, b, c): n.css (a, b)g = 0; if (n.isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g], 1, d); return f} return void 0! == c? n.style (a, b, c): n.css (a, b)g = 0; if (n.isArray (b)) {para (d = Jb (a), e = b.length; e> g; g ++) f [b [g]] = n.css (a, b [g], 1, d); return f} return void 0! == c? n.style (a, b, c): n.css (a, b)
}, a, b, argument.length> 1)}, show: function () {return Wb (this,! 0)}, hide: function () {return Wb (this)}, toggle: function (a) { devuelve "boolean" == typeof a? a? this.show (): this.hide (): this.each (function () {V (this)? n (this) .show (): n (this). hide ()})}}); function $ b (a, b, c, d, e) {return new $ b.prototype.init (a, b, c, d, e)} n.Tween = $ b , $ b.prototype = {constructor: $ b, init: function (a, b, c, d, e, f) {this.elem = a, this.prop = c, this.easing = e || "swing ", this.options = b, this.start = this.now = this.cur (), this.end = d, this.unit = f || (n.cssNumber [c]?" ":" px ") }, cur: function () {var a = $ b.propHooks [this.prop]; devolver un && a.get? a.get (this): $ b.propHooks._default.get (this)}, ejecute: function ( a) {var b, c = $ b.propHooks [this.prop]; return this.pos = b = this.options.duration? n.easing [this.easing] (a, this.options.duration * a, 0,1, this.options.duration): a, this.now = (this.end-this.inicio) * b + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), c && c.set? c.set (this): $ b.propHooks._default. set (this), this}}, $ b.prototype.init.prototype = $ b.prototype, $ b.propHooks = {_ default: {get: function (a) {var b; return null == a.elem [ a.prop] || a.elem.style && null! = a.elem.style [aprop]? (b = n.css (a.elem, a.prop, ""), b && "auto"! == b? b: 0): a.elem [a.prop]}, set: function ( a) {n.fx.step [a.prop]? n.fx.step [a.prop] (a): a.elem.style && (null! = a.elem.style [n.cssProps [a.prop ]] || n.cssHooks [a.prop])? n.style (a.elem, a.prop, a.now + a.unit): a.elem [a.prop] = a.now}}} , $ b.propHooks.scrollTop = $ b.propHooks.scrollLeft = {set: function (a) {a.elem.nodeType && a.elem.parentNode && (a.elem [a.prop] = a.now)}}, n .easing = {linear: function (a) {return a}, swing: function (a) {return.5-Math.cos (a * Math.PI) / 2}}, n.fx = $ b.prototype. init, n.fx.step = {}; var _b, ac, bc = / ^ (?: toggle | show | hide) $ /, cc = new RegExp ("^ (?: ([+ -]) = | ) ("+ T +") ([az%] *) $ "," i "), dc = / queueHooks $ /, ec = [jc], fc = {" * ": [function (a, b) { var c = this.createTween (a, b), d = c.cur (), e = cc.exec (b), f = e && e [3] || (n.cssNumber [a]? "": "px "), g = (n.cssNumber [a] || "px"! == f && + d) && cc.exec (n.css (c.elem, a)), h = 1, i = 20; if (g && g [3]! == f ) {f = f || g [3], e = e || [], g = + d || 1; do h = h || ".5", g / = h, n.style (c. elem, a, g + f); mientras que (h! == (h = c.cur () / d) && 1! == h && - i)} devuelve e && (g = c.start = + g || + d || 0, c.unit = f, c.end = e [1]? g + (e [1] +1) * e [2]: + e [2]), c}]}; función gc ( ) {return setTimeout (function () {_ b = void 0}), _ b = n.now ()} función hc (a, b) {var c, d = {altura: a}, e = 0; para (b = b? 1: 0; 4> e; e + = 2-b) c = U [e], d ["margen" + c] = d ["relleno" + c] = a; retorno b && (d.opacidad = d.width = a), d} función ic (a, b, c) {para (var d, e = (fc [b] || []). concat (fc ["*"]), f = 0, g = e.length; g> f; f ++) if (d = e [f] .call (c, b, a)) devuelve d} función jc (a, b, c) {var d, e, f, g, h, i, j, k, m = esto, o = {}, p = a.style, q = a.nodeType && V (a), r = n._data (a, "fxshow"); c .queue || (h = n._queueHooks (a, "fx"), null == h.sin cola && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {h.unqueued || i ()}), h.unqueued ++, m.always (function () {m .always (function () {h.unqueued -, n.queue (a, "fx"). length || h.empty.fire ()})})), 1 === a.nodeType && ("altura "in b ||" width "en b) && (c.overflow = [p.overflow, p.overflowX, p.overflowY], j = n.css (a," display "), k = Gb (a. nodeName), "none" === j && (j = k), "inline" === j && "none" === n.css (a, "float") && (l.inlineBlockNeedsLayout && "inline"! == k? p.zoom = 1: p.display = "inline-block")), c.overflow && (p.overflow = "hidden", l.shrinkWrapBlocks () || m.always (function () {p.overflow = c.overflow [0], p.overflowX = c.overflow [1], p.overflowY = c.overflow [2]})); para (d in b) if (e = b [d], bc. exec (e)) {if (eliminar b [d], f = f || "alternar"=== e, e === (q? "hide": "show")) {if ("show"! == e ||! r || void 0 === r [d]) continue; q =! 0} o [d] = r && r [d] || n.style (a, d)} if (! N.isEmptyObject (o)) {r? "Hidden" en r && (q = r.hidden): r = n._data (a, "fxshow", {}), f && (r.hidden =! q), q? n (a) .show (): m.done (function () {n (a). hide ()}), m.done (function () {var b; n._removeData (a, "fxshow"); para (b in o) n.style (a, b, o [b])}); para (d en o) g = ic (q? r [d]: 0, d, m), d en r || (r [d] = g.start, q && (g.end = g.start, g .start = "ancho" === d || "altura" === d? 1: 0))}} función kc (a, b) {var c, d, e, f, g; para (c in a) si (d = n.camelCase (c), e = b [d], f = a [c], n.isArray (f) && (e = f [1], f = a [c] = f [0]), c! == d && (a [d] = f, eliminar a [c]), g = n.cssHooks [d], g && "expandir" en g) {f = g.expand (f) , elimine a [d]; para (c en f) c en a || (a [c] = f [c], b [c] = e)} else b [d] = e} función lc (a, b, c) {var d, e, f = 0,g = ec.length, h = n.Deferred (). always (function () {delete i.elem}), i = function () {if (e) return! 1; for (var b = _b || gc (), c = Math.max (0, j.startTime + j.duration-b), d = c / j.duration || 0, f = 1-d, g = 0, i = j.tweens.length ; i> g; g ++) j.tweens [g] .run (f); devolver h.notifyWith (a, [j, f, c]), 1> f && i? c: (h.resolveWith (a, [j ]),! 1)}, j = h.promise ({elem: a, props: n.extend ({}, b), opts: n.extend (! 0, {specialEasing: {}}, c), OriginalProperties: b, originalOptions: c, startTime: _b || gc (), duración: c.duration, tweens: [], createTween: function (b, c) {var d = n.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing); return j.tweens.push (d), d}, detener: función (b) {var c = 0, d = b? j.tweens.length: 0; if (e) devuelve esto; para (e =! 0; d> c; c ++) j.tweens [c] .run (1); return b? h.resolveWith (a, [ j, b]): h.rejectWith (a, [j, b]), this}}), k = j.props; para (kc (k, j.opts.special.asing); g> f; f ++) si (d = ec [f] .call (j, a, k, j.opts)) devuelve d; devuelve n.map (k,ic, j), n.isFunction (j.opts.start) && j.opts.start.call (a, j), n.fx.timer (n.extendente (i, {elem: a, anim: j, cola : j.opts.queue})), j.progress (j.opts.progress) .done (j.opts.done, j.opts.complete) .fail (j.opts.fail) .always (j.opts .always)} n.Animation = n.extextend (lc, {tweener: function (a, b) {n.isFunction (a)? (b = a, a = ["*"]): a = a.split (""); para (var c, d = 0, e = a.length; e> d; d ++) c = a [d], fc [c] = fc [c] || [], fc [c ] .unshift (b)}, prefiltro: función (a, b) {b? ec.unshift (a): ec.push (a)}}), n.speed = función (a, b, c) {var d = a && "objeto" == typeof a? n.extextend ({}, a): {complete: c ||! c && b || n.isFunction (a) && a, duration: a, easing: c && b || b &&! n.isFunction (b) && b}; return d.duration = n.fx.off? 0: "number" == typeof d.duration? d.duration: d.duration en n.fx.speeds? n.fx. velocidades [d.duration]: n.fx.speeds._default, (null == d.queue || d.queue ===!0) && (d.queue = "fx"), d.old = d.complete, d.complete = function () {n.isFunction (d.old) && d.old.call (this), d.queue && n. dequeue (this, d.queue)}, d}, n.fn.extend ({fadeTo: function (a, b, c, d) {return this.filter (V) .css ("opacity", 0). show (). end (). animate ({opacity: b}, a, c, d)}, animate: function (a, b, c, d) {var e = n.isEmptyObject (a), f = n .speed (b, c, d), g = function () {var b = lc (this, n.extend ({}, a), f); (e || n._data (this, "finish") ) && b.stop (! 0)}; devolver g.finish = g, e || f.queue ===! 1? this.each (g): this.queue (f.queue, g)}, deténgase: función (a, b, c) {var d = función (a) {var b = a.stop; delete a.stop, b (c)}; devolver "cadena"! = tipo de a && (c = b, b = a, a = void 0), b && a! ==! 1 && this.queue (a || "fx", []), this.each (function () {var b =! 0, e = null! = a && a + "queueHooks ", f = n.timers, g = n._data (esto); if (e) g [e] && g [e].stop && d (g [e]) else para (e en g) g [e] && g [e] .stop && dc.test (e) && d (g [e]); para (e = f.length; e--; ) f [e] .elem! == este || null! = a && f [e] .queue! == a || (f [e] .anim.stop (c), b =! 1, f.splice ( e, 1)); (b ||! c) && n.dequeue (this, a)})}, finish: function (a) {return a! ==! 1 && (a = a || "fx"), this.each (function () {var b, c = n._data (this), d = c [a + "queue"], e = c [a + "queueHooks"], f = n.timers, g = d? d.length: 0; para (c.finish =! 0, n.queue (this, a, []), e && e.stop && e.stop.call (this,! 0), b = f.length; b-- ;) f [b] .elem === este && f [b] .queue === a && (f [b] .anim.stop (! 0), f.splice (b, 1)); para (b = 0 ; g> b; b ++) d [b] && d [b] .finish && d [b] .finish.call (this); delete c.finish})}}), n.each (["toggle", "show" , "ocultar"], función (a, b) {var c = n.fn [b]; n.fn [b] = función (a, d, e) {return null == a || "boolean "== typeof a? c.apply (this, argumentos): this.animate (hc (b,! 0), a, d, e)}}), n.each ({slideDown: hc (" show " ), slideUp: hc ("hide"), slideToggle: hc ("toggle"), fadeIn: {opacity: "show"}, fadeOut: {opacity: "hide"}, fadeToggle: {opacity: "toggle"}} , función (a, b) {n.fn [a] = función (a, c, d) {devuelve this.animate (b, a, c, d)}}), n.timers = [], n. fx.tick = function () {var a, b = n.timers, c = 0; para (_b = n.now (); c <b.length; c ++) a = b [c], a () | | b [c]! == a || b.splice (c -, 1); b.length || n.fx.stop (), _ b = void 0}, n.fx.timer = function (a ) {n.timers.push (a), a ()? n.fx.start (): n.timers.pop ()}, n.fx.interval = 13, n.fx.start = function () { ac || (ac = setInterval (n.fx.tick, n.fx.interval))}, n.fx.stop = function () {clearInterval (ac), ac = null}, n.fx.speeds = { lento: 600, rápido: 200, _fault: 400}, n.fn.delay = function (a, b) {return a = n.fx? n.fx.speeds [a] || a: a, b = b || "fx", esto.queue (b, function (b, c) {var d = setTimeout (b, a); c.stop = function () {clearTimeout (d)}})}, function () {var a, b, c, d , e = z.createElement ("div"); e.setAttribute ("className", "t"), e.innerHTML = "<link/><table> </table> <a href='/a'> a </a> <input type = 'checkbox' /> ", a = e.getElementsByTagName (" a ") [0], c = z.createElement (" select "), d = c.appendChild (z.createElement ("opción")), b = e.getElementsByTagName ("input") [0], a.style.cssText = "top: 1px", l.getSetAttribute = "t"! == e.className, l.style = / top / .test (a.getAttribute ("style")), l.hrefNormalized = "/ a" === a.getAttribute ("href"), l.checkOn = !! b.value, l.optSelected = d.selected, l.enctype = !! z.createElement ("form"). enctype, c.disabled =! 0, l.optDisabled =! d.disabled,b = z.createElement ("input"), b.setAttribute ("value", ""), l.input = "" === b.getAttribute ("value"), b.value = "t", b .setAttribute ("type", "radio"), l.radioValue = "t" === b.value, a = b = c = d = e = null} (); var mc = / \ r / g; n.fn.extend ({val: function (a) {var b, c, d, e = this [0]; {if (argumentos.length) devuelve d = n.isFunction (a), this.each (function (c) {var e; 1 === this.nodeType && (e = d? a.call (this, c, n (this) .val ()): a, null == e? e = "": " número "== tipo de e? e + =" ": n.isArray (e) && (e = n.map (e, función (a) {return null == a?" ": a +" "})), b = n.valHooks [this.type] || n.valHooks [this.nodeName.toLowerCase ()], b && "set" en b && void 0! == b.set (this, e, "value") || (this .value = e))}); if (e) devuelve b = n.valHooks [e.type] || n.valHooks [e.nodeName.toLowerCase ()], b && "get" in b && void 0! == (c = b.get (e, "value"))? c: (c = e.value, "string" == typeof c? c.replace (mc, ""): null == c? "": c)}}}), n.extextend ({valHooks: {option: {get: function (a) {var b = n.find.attr (a , "valor"); return null! = b? b: n.text (a)}}, seleccione: {obtener: función (a) {para (var b, c, d = a.options, e = a. selectedIndex, f = "select-one" === a.type || 0> e, g = f? null: [], h = f? e + 1: d.length, i = 0> e? h: f? e: 0; h> i; i ++) if (c = d [i],! (! c.selected && i! == e || (l.optDisabled? c.disabled: null! == c.getAttribute ( "deshabilitado")) || c.parentNode.disabled && n.nodeName (c.parentNode, "optgroup"))) {if (b = n (c) .val (), f) return b; g.push (b) } return g}, set: function (a, b) {var c, d, e = a.options, f = n.makeArray (b), g = e.length; while (g -) if (d = e [g], n.inArray (n.valHooks.option.get (d), f)> = 0) intente {d.selected = c =!0} catch (h) {d.scrollHeight} else d.selected =! 1; return c || (a.selectedIndex = -1), e}}}}), n.each (["radio", "checkbox "], function () {n.valHooks [this] = {set: function (a, b) {return n.isArray (b)? a.checked = n.inArray (n (a) .val (), b )> = 0: void 0}}, l.checkOn || (n.valHooks [this] .get = function (a) {return null === a.getAttribute ("value")? "On": a. valor})}); var nc, oc, pc = n.expr.attrHandle, qc = / ^ (?: seleccionado | seleccionado) $ / i, rc = l.getSetAttribute, sc = l.input; n.fn. extend ({attr: function (a, b) {return W (this, n.attr, a, b, argumentos.length> 1)}, removeAttr: function (a) {return this.each (function () {n .removeAttr (this, a)})}}), n.extextend ({attr: function (a, b, c) {var d, e, f = a.nodeType; if (a && 3! == f && 8! == f && 2! == f) devuelve typeof a.getAttribute === L? n.prop (a, b, c) :( 1 === f && n.isXMLDoc (a) || (b = b.toLowerCase (), d = n.attrHooks [b] || (n.expr.match.bool.test (b)? oc: nc)), void 0 === c? d && "get" en d && null! == (e = d.get (a, b))? e: (e = n.find.attr (a, b), null == e? void 0: e): null! == c? d && "set" en d && void 0! == (e = d.set (a, c, b)) e: (a.setAttribute (b, c + ""), c): void n.removeAttr (a, b))}, removeAttr: function (a, b) {var c, d, e = 0, f = b && b.match (F); if (f && 1 === a.nodeType) while (c = f [e ++]) d = n.propFix [c] || c, n.expr.match.bool.test (c)? Sc && rc | |! qc.test (c)? a [d] =! 1: a [n.camelCase ("predeterminado -" + c)] = a [d] =! 1: n.attr (a, c, "" ), a.removeAttribute (rc? c: d)}, attrHooks: {type: {set: function (a, b) {if (! l.radioValue && "radio" === b && n.nodeName (a, "entrada" )) {var c = a.value; return a.setAttribute ("type", b), c && (a.value = c), b}}}}}), oc = {set: function (a, b, c) {return b ===! 1? n.removeAttr (a, c): sc && rc ||! qc.test (c)? a.setAttribute (! rc && n.propFix [c] || c, c): a [n.camelCase ("default -" + c)] = a [c] =! 0, c}}, n.each (n.expr .match.bool.source.match (/ \ w + / g), función (a, b) {var c = pc [b] || n.find.attr; pc [b] = sc && rc ||! qc.test (b) función? (a, b, d) {var e, f; devolver d || (f = pc [b], pc [b] = e, e = nulo! = c (a, b, d) ? b.toLowerCase (): null, pc [b] = f), e}: function (a, b, c) {return c? void 0: a [n.camelCase ("default -" + b)]? b.toLowerCase (): null}}), sc && rc || (n.attrHooks.value = {set: function (a, b, c) {return n.nodeName (a, "input")? void (a.defaultValue = b): nc && nc.set (a, b, c)}}), rc || (nc = {set: function (a, b, c) {var d = a.getAttributeNode (c); return d || a.setAttributeNode (d = a.ownerDocument.createAttribute (c)), d.value = b + = "", "value" === c || b === a.getAttribute (c)? b: void 0} }, pc.id = pc.name = pc.coords = function (a, b, c) {var d; return c? void 0: (d = a.getAttributeNode (b)) &&""! == d.value? d.value: null}, n.valHooks.button = {get: function (a, b) {var c = a.getAttributeNode (b); devuelva c && c.specified? c.value : void 0}, set: nc.set}, n.attrHooks.contenteditable = {set: function (a, b, c) {nc.set (a, "" === b?! 1: b, c) }}, n.cantidad (["ancho", "altura"], función (a, b) {n.attrHooks [b] = {set: function (a, c) {return "" === c? ( a.setAttribute (b, "auto"), c): void 0}}})), l.style || (n.attrHooks.style = {get: function (a) {return a.style.cssText || void 0}, set: function (a, b) {return a.style.cssText = b + ""}}); var tc = / ^ (?: input | select | textarea | button | object) $ / i, uc = / ^ (?: a | area) $ / i; n.fn.extend ({prop: function (a, b) {return W (this, n.prop, a, b, argument.length> 1)} , removeProp: function (a) {return a = n.propFix [a] || a, this.each (function () {try {this [a] = void 0, eliminar este [a]} catch (b) { }})}}), n.extextend ({propFix: {"for":"htmlFor", "class": "className"}, prop: function (a, b, c) {var d, e, f, g = a.nodeType; if (a && 3! == g && 8! == g && 2! = = g) devuelve f = 1! == g ||! n.isXMLDoc (a), f && (b = n.propFix [b] || b, e = n.propHooks [b]), void 0! == c? e && "set" en e && void 0! == (d = e.set (a, c, b)) d: a [b] = c: e && "get" en e && null! == (d = e. get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: function (a) {var b = n.find.attr (a, "tabindex"); return b? parseInt ( b, 10): tc.test (a.nodeName) || uc.test (a.nodeName) && a.href? 0: -1}}}}), l.hrefNormalized || n.each (["href" , "src"], function (a, b) {n.propHooks [b] = {get: function (a) {return a.getAttribute (b, 4)}}}), l.optSelected || (n. propHooks.selected = {get: function (a) {var b = a.parentNode; return b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex),null}}), n.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"] , function () {n.propFix [this.toLowerCase ()] = this}), l.enctype || (n.propFix.enctype = "encoding"); var vc = / [\ t \ r \ n \ f ] /g;n.fn.extend ({addClass: function (a) {var b, c, d, e, f, g, h = 0, i = this.length, j = "string" == typeof a && a ; if (n.isFunction (a)) devuelve this.each (function (b) {n (this) .addClass (a.call (this, b, this.className))); if (j) para (b = (a || ""). match (F) || []; i> h; h ++) if (c = this [h], d = 1 === c.nodeType && (c.className? ("" + c.className + "") .replace (vc, ""): "")) {f = 0; while (e = b [f ++]) d.indexOf ("" + e + "") <0 && (d + = e + ""); g = n.trim (d), c.className! == g && (c.className = g)} devolver esto}, removeClass: function (a) {var b, c, d, e, f, g, h = 0, i = this.length, j = 0 === argumentos.length || "string" == typeof a && a; if (n.isFunction (a)) devuelve this.each (function (b) {n (this) .removeClass (a .call (this, b, this.className)}); if (j) para (b = (a || ""). match (F) || []; i> h; h ++) if (c = este [h], d = 1 === c.nodeType && (c.className? ("" + c.className + "") .replace (vc, ""): "")) {f = 0; while (e = b [f ++]) while (d.indexOf ("" + e + "")> = 0) d = d.replace ("" + e + "", "); g = a? n.trim (d) : "", c.className! == g && (c.className = g)} devolver esto}, toggleClass: function (a, b) {var c = typeof a; return "boolean" == typeof b && "string" = == c? b? this.addClass (a): this.removeClass (a): this.each (n.isFunction (a)? function (c) {n (this) .toggleClass (a.call (this, c, this.className, b), b)}: function () {if ("string" === c) {var b, d = 0, e = n (este), f = a.match (F) || []; mientras que (b = f [d ++]) e.hasClass (b)? e.removeClass (b) : e.addClass (b)} else (c === L || "boolean" === c) && (this.className && n._data (this, "__ className __", this.className), this.className = this. className || a ===! 1? "": n._data (this, "__ className __") || "")})}, hasClass: function (a) {for (var b = "" + a + "" , c = 0, d = this.length; d> c; c ++) if (1 === this [c] .nodeType && ("" + this [c] .className + "") .replace (vc, "") .indexOf (b)> = 0) return! 0; return! 1}}), n.each ("difuminar foco enfocar enfocar cargar cambiar tamaño desplazarse descargar dblclick mousedown mouseup mousemove mouseover mouseover mouseenter mouseleave cambiar seleccionar enviar tecla abajo tecla tecla tecla menú menú ".split (" "), function (a, b) {n.fn [b] = function (a , c) {return actions.length> 0? this.on (b, null, a, c): this.trigger (b)}}), n.fn.extend ({hover: function (a, b) { devuelva this.mouseenter (a) .mouseleave (b || a)}, bind: function (a, b, c) {return this.on (a, null, b, c)}, unbind: function (a, b ) {return this.off (a, null, b)}, delegate: function (a, b, c, d) {return this.on (b, a, c, d)}, undelegate: function (a, b , c) {devolver 1 === argumentos.longitud? this.off (a, "**"): this.off (b, a || "**", c)}}); var wc = n. ahora (), xc = / \? /, yc = / (,) | (\ [| {) | (} |]) | "(?: [^" \\\ r \ n] | \\ [" \\\ / bfnrt] | \\ u [\ da-fA-F] {4}) * "\ s * :? | true | false | null | -? (?! 0 \ d) \ d + (?: \. \ d + |) (?: [eE] [+ -]? \ d + |) / g; n.parseJSON = function (b) {if (a.JSON && a.JSON.parse) return a.JSON.parse (b + ""); var c, d = null, e = n.trim (b + ""); devuelva e &&! n.trim (e.replace (yc, función (a, b, e, f) {return c && b && (d = 0), 0 === d? a: (c = e || b, d + =! f- ! e, "")}))? Function ("return" + e) ​​(): n.error ("JSON no válido:" + b)}, n.parseXML = function (b) {var c, d; if (! b || "string"! = typeof b) return null; intente {a.DOMParser? (d = new DOMParser, c = d.parseFromString (b, "text / xml")) :( c = new ActiveXObject ( "Microsoft.XMLDOM"), c.async = "false", c.loadXML (b))} catch (e) {c = void 0} return c && c.documentElement &&! C.getElementsByTagName ("parsererror"). Length || n.error ("XML no válido:" + b), c}; var zc, Ac, Bc = / #. * $ /, Cc = / ([? &]) _ = [^ &] * /, Dc = / ^ (. *?): [\ t] * ([^ \ r \ n] *) \ r? $ / gm, Ec = / ^ (?: about | app | app-storage |.+ -extensión | archivo | res | widget): $ /, Fc = / ^ (?: GET | HEAD) $ /, Gc = / ^ \ / \ //, Hc = / ^ ([\ w. + -] +:) (?: \ / \ / (?: [^ \ /? #] * @ |) ([^ \ /? #:] *) (? :: (\ d +) |) |) /, Ic = {}, Jc = {}, Kc = "* /". Concat ("*"); intente {Ac = location.href} catch (Lc) {Ac = z.createElement ("a"), Ac.href = "", Ac = Ac.href} zc = Hc.exec (Ac.toLowerCase ()) || []; function Mc (a) {return function (b, c) {"string"! = Typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase (). match (F) || []; if (n.isFunction (c)) while (d = f [e ++ ]) "+" === d.charAt (0)? (d = d.slice (1) || "*", (a [d] = a [d] || []). Unshift (c) ) :( a [d] = a [d] || []). push (c)}} función Nc (a, b, c, d) {var e = {}, f = a === Jc; función g (h) {var i; devuelve e [h] =! 0, n.each (a [h] || [], función (a, h) {var j = h (b, c, d); devuelve "string"! = typeof j || f || e [j]? f?! (i = j): void 0: (b.dataTypes.unshift (j), g (j) ,! 1)}) , i} devuelve g (b.dataTypes [0]) ||! e ["*"] &&g ("*")} función Oc (a, b) {var c, d, e = n.ajaxSettings.flatOptions || {}; para (d in b) void 0! == b [d] && (( e [d]? a: c || (c = {})) [d] = b [d]); devuelva c && n.extendido (! 0, a, c), a} función Pc (a, b, c) ) {var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i [0]) i.shift (), void 0 === e && (e = a.mimeType || b.getResponseHeader ("Content-Type")); if (e) para (g in h) if (h [g] && h [g] .test (e)) {i.unshift (g ); break} if (i [0] en c) f = i [0]; else {for (g in c) {if (! i [0] || a.converters [g + "" + i [0] ]) {f = g; break} d || (d = g)} f = f || d} return f? (f! == i [0] && i.unshift (f), c [f]): void 0} función Qc (a, b, c, d) {var e, f, g, h, i, j = {}, k = a.dataTypes.slice (); if (k [1]) para ( g en a.converters) j [g.toLowerCase ()] = a.converters [g]; f = k.shift (); while (f) if (a.responseFields [f] && (c [a.responseFields [ f]] = b) ,! i && d && a.dataFilter && (b = a.dataFilter (b, a.tipo de datos)), i = f, f = k.shift ()) if ("*" === f) f = i; si no ("*"! == i && i! == f) {if (g = j [i + "" + f] || j ["*" + f] ,! g) para (e en j) if (h = e.split (""), h [1] === f && (g = j [i + "" + h [0]] || j ["*" + h [0]])) {g ===! 0? g = j [e]: j [e]! ==! 0 && (f = h [0], k.unshift (h [1])); break} if (g! ==! 0) if (g && a ["throws"]) b = g (b); de lo contrario, intente { b = g (b)} catch (l) {return {state: "parsererror", error: g? l: "No hay conversión de" + i + "a" + f}}} return {state: "success", data : b}} n.extextend ({active: 0, LastModified: {}, etag: {}, ajaxSettings: {url: Ac, escriba: "GET", isLocal: Ec.test (zc [1]), global: ! 0, processData:! 0, async:! 0, contentType: "application / x-www-form-urlencoded; charset = UTF-8", acepta: {"*": Kc, text: "text / plain", html: "texto / html", xml: "application / xml, text / xml ", json:" application / json, text / javascript "}, contenidos: {xml: / xml /, html: / html /, json: / json /}, responseFields: {xml:" responseXML ", text:" responseText ", json:" responseJSON "}, converters: {" * text ": String," text html ":! 0," text json ": n.parseJSON," text xml ": n. parseXML}, flatOptions: {url:! 0, context:! 0}}, ajaxSetup: function (a, b) {return b? Oc (Oc (a, n.ajaxSettings), b): Oc (n.ajaxSettings, a)}, ajaxPrefilter: Mc (Ic), ajaxTransport: Mc (Jc), ajax: función (a, b) {"objeto" == tipo de a && (b = a, a = vacío 0), b = b || {}; var c, d, e, f, g, h, i, j, k = n.ajaxSetup ({}, b), l = k.context || k, m = k.context && (l.nodeType || l.jquery)? n (l): n.event, o = n.Deferred (), p = n.Callbacks ("once memory"), q = k.statusCode || {}, r = {} , s = {}, t = 0, u = "cancelado", v = {readyState: 0, getResponseHeader:función (a) {var b; if (2 === t) {si (! j) {j = {}; mientras que (b = Dc.exec (f)) j [b [1] .toLowerCase ()] = b [2]} b = j [a.toLowerCase ()]} return null == b? null: b}, getAllResponseHeaders: function () {return 2 === t? f: null}, setRequestHeader: function ( a, b) {var c = a.toLowerCase (); devolver t || (a = s [c] = s [c] || a, r [a] = b), this}, overrideMimeType: function (a ) {return t || (k.mimeType = a), this}, statusCode: function (a) {var b; if (a) if (2> t) para (b in a) q [b] = [q [b], a [b]]; else v.always (a [v.status]); return this}, abort: function (a) {var b = a || u; return i && i.abort (b), x (0, b), this}}; if (o.promise (v) .complete = p.add, v.success = v.done, v.error = v.fail, k.url = ((a | | k.url || Ac) + ""). replace (Bc, ""). replace (Gc, zc [1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = n.trim (k.dataType || "*". toLowerCase (). match (F) || [""], null == k.crossDomain && (c = Hc.exec (k.url.toLowerCase ()), k.crossDomain =! (! c || c [1] === zc [1] && c [2] === zc [2] && (c [3] || ("http:" === c [1]? "80": "443")) === (zc [3] || ("http:" === zc [1]? "80": "443"))) ), k.data && k.processData && "cadena"! = tipo de k.data && (k.data = n.param (k.data, k.traditional)), Nc (Ic, k, b, v), 2 === t) devuelva v; h = k.global, h && 0 === n.active ++ && n.event.trigger ("ajaxStart"), k.type = k.type.toUpperCase (), k.hasContent =! Fc. test (k.type), e = k.url, k.hasContent || (k.data && (e = k.url + = (xc.test (e)? "&": "?") + k.data, eliminar k.data), k.cache ===! 1 && (k.url = Cc.test (e)? e.replace (Cc, "$ 1 _ =" + wc ++): e + (xc.test (e)? "&": "?") + "_ =" + wc ++)), k.ifModified && (n.lastModified [e] && v.setRequestHeader ("If-Modified-Since ", n.lastModified [e]), n.etag [e] && v.setRequestHeader (" If-None-Match ", n.etag [e])), (k.data && k.hasContent && k.contentType ! ==! 1 || b.contentType) && v.setRequestHeader ("Content-Type", k.contentType), v.setRequestHeader ("Accept", k.dataTypes [0] && k.accepts [k.dataTypes [0] ]? k.accepts [k.dataTypes [0]] + ("*"! == k.dataTypes [0]? "," + Kc + "; q = 0.01": ""): k.accepts ["* "]); para (d en k.headers) v.setRequestHeader (d, k.headers [d]); if (k.foreforeSend && (k.foreforeSend.call (l, v, k) ===! 1 | | 2 === t)) devolver v.abort (); u = "abortar"; para (d en {success: 1, error: 1, complete: 1}) v [d] (k [d]); if (i = Nc (Jc, k, b, v)) {v.readyState = 1, h && m.trigger ("ajaxSend", [v, k]), k.async && k.timeout> 0 && (g = setTimeout (función () {v.abort ("timeout ")}, k.timeout)); intente {t = 1, i.send (r, x)} catch (w) {if (! (2> t)) despierte w; x (-1, w) }} else else x (-1, "No Transport"); función x (a, b, c, d) {var j, r, s, u, w, x = b; 2! == t && (t = 2 , g && clearTimeout (g), i = void 0, f = d || "", v.readyState = a> 0? 4: 0, j = a> = 200 && 300> a || 304 === a, c && (u = Pc (k, v, c)), u = Qc (k, u, v, j), j? (K.ifModified && (w = v.getResponseHeader ("Last-Modified"), w && (n.lastModified [ e] = w), w = v.getResponseHeader ("etag"), w && (n.etag [e] = w)), 204 === a || "HEAD" === k.type? x = " nocontent ": 304 === a? x =" notmodified ":( x = u.state, r = u.data, s = u.error, j =! s)) :( s = x, (a || ! x) && (x = "error", 0> a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j? o.resolveWith (l, [r, x, v]): o.rejectWith (l, [v, x, s]), v.statusCode (q), q = void 0, h && m.trigger (j? "ajaxSuccess ":" ajaxError ", [v, k, j? r: s]), p.fireWith (l, [v, x]), h && (m.trigger (" ajaxComplete ", [v, k]), --n.active || n.event.trigger ("ajaxStop")))} return v}, getJSON: function (a, b, c) {return n.get (a, b, c, "json") }, getScript: function (a, b) {return n.get (a, void 0, b, "script")}}), n.each (["get", "post"], función (a, b ) {n [b] = función (a, c, d, e) {return n.isFunction (c) && (e = e || d, d = c, c = void 0), n.ajax ({url : a, escriba: b, dataType: e, data: c, success: d})}}), n.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", " ajaxSend "], function (a, b) {n.fn [b] = function (a) {return this.on (b, a)}}), n._evalUrl = function (a) {return n.ajax ( {url: a, escriba: "GET", dataType: "script", async:! 1, global:! 1, "throws":! 0})}, n.fn.extend ({wrapAll: function (a) {if (n.isFunction (a)) devuelve this.each (function (b) {n (this) .wrapAll (a.call (this, b))}); if ( este [0]) {var b = n (a, este [0] .ownerDocument) .eq (0) .clone (! 0); este [0] .parentNode && b.insertBefore (this [0]), b.map (function () {var a = this; while (a.firstChild && 1 === a.firstChild.nodeType) a = a.firstChild; return a}). append (this)} return this}, wrapInner: function (a) {devuelva this.each (n.isFunction (a)? function (b) {n (this) .wrapInner (a.call (this, b))}: function () {var b = n (this), c = b.contents (); c.length? c.wrapAll (a): b.append (a)})}, wrap: function (a) {var b = n.isFunction (a); devuelva this.each (función (c) {n (this) .wrapAll (b? a.call (this, c): a)})}, unwrap: function () {return this.parent (). each (function () {n.nodeName (this, "body") || n (this) .replaceWith (this.childNodes)}). end ()}}), n.expr.filters.hidden = function (a) {return a.offsetWidth <= 0 && a .offsetHeight <= 0 ||! l.reliableHiddenOffsets () && "none" === (a.style && a.style.display || n.css (a, "display"))}, n.expr.filters.visible = función (a) {return! n.expr.filters.hidden (a)}; var Rc = /% 20 / g, Sc = / \ [\] $ /, Tc = / \ r? \ n / g, Uc = / ^ (?: enviar | botón | imagen | restablecer | archivo) $ / i, Vc = / ^ (?: entrada | seleccionar | textarea | keygen) / i; función Wc (a, b, c, d) { var e; if (n.isArray (b)) ns (b, función (b, e) {c || Sc.test (a)? d (a, e): Wc (a + "[" + ( "object" == typeof e? b: "") + "]", e, c, d)}); de lo contrario, si (c || "object"! == n.type (b)) d (a, b); también para (e en b) Wc (a + "[" + e + "]", b [e], c, d)} n.param = función (a, b) {var c, d = [] , e = función (a, b) {b = n.isFunction (b)? b (): null == b? "": b, d [d.length] = encodeURIComponent (a) + "=" + encodeURIComponent (b)}; if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray (a) || a.jquery &&! n.isPlainObject (a)) n.each (a, function () {e (this.name, this.value)}); else para (c en a) Wc (c , a [c], b, e); return d.join ("&"). replace (Rc, "+")}, n.fn.extend ({serialize: function () {return n.param (this .serializeArray ())}, serializeArray: function () {return this.map (function () {var a = n.prop (this, "elements"); return a? n.makeArray (a): this}). filter (function () {var a = this.type; devolver this.name &&! n (this) .is (": disabled") && Vc.test (this.nodeName) &&! Uc.test (a) && (this. marcado ||! X.test (a))}). map (function (a, b) {var c = n (this) .val (); return null == c? null: n.isArray (c)? n.map (c, función (a) {return {nombre: b.nombre, valor: a.replace (Tc, "\ r \ n")}}): {nombre: b.name, valor: c.replace (Tc, "\ r \ n")}}). Get ()}}), n.ajaxSettings.xhr = void 0! == a.ActiveXObject? Function () {return! This.isLocal && / ^ (obtener | publicar | encabezar | eliminar | opciones) $ / i.test (this.type) && $ c () || _c ()}: $ c; var Xc = 0, Yc = {} , Zc = n.ajaxSettings.xhr (); a.ActiveXObject && n (a) .on ("unload", function () {for (var a en Yc) Yc [a] (void 0,! 0)}), l .cors =! Zc && "withCredentials" en Zc, Zc = l.ajax = !! Zc, Zc && n.ajaxTransport (función (a) {si (! a.crossDomain || l.cors) {var b; retorno {enviar : función (c, d) {var e, f = a.xhr (), g = ++ Xc; if (f.open (a.type, a.url, a.async, a.username, a.password ), a.xhrFields) para (e en a.xhrFields) f [e] = a.xhrFields [e]; a.mimeType && f.overrideMimeType && f.overrideMimeType (a.mimeType), a.crossDomain || c ["X-Requested -Con "] || (c [" X-Requested-With "] =" XMLHttpRequest "); para (e in c) void 0! == c [e] && f.setRequestHeader (e, c [e] +" "); f.send (a.hasContent && a.data || null), b = function (c, e) {var h,i, j; if (b && (e || 4 === f.readyState)) if (borrar Yc [g], b = void 0, f.onreadystatechange = n.noop, e) 4! == f.readyState && f .abort (); else {j = {}, h = f.status, "string" == typeof f.responseText && (j.text = f.responseText); intente {i = f.statusText} catch (k) { i = ""} h ||! a.isLocal || a.crossDomain? 1223 === h && (h = 204): h = j.text? 200: 404} j && d (h, i, j, f.getAllResponseHeaders ())}, a.async? 4 === f.readyState? setTimeout (b): f.onreadystatechange = Yc [g] = b: b ()}, abort: function () {b && b (void 0 ,! 0)}}}}); function $ c () {try {return new a.XMLHttpRequest} catch (b) {}} function _c () {try {return new a.ActiveXObject ("Microsoft.XMLHTTP")} catch (b) {}} n.ajaxSetup ({acepta: {script: "text / javascript, application / javascript, application / ecmascript, application / x-ecmascript"}, contenidos: {script: / (?: java | ecma) script /}, convertidores: {"script de texto":function (a) {return n.globalEval (a), a}}}), n.ajaxPrefilter ("script", función (a) {void 0 === a.cache && (a.cache =! 1), a .crossDomain && (a.type = "GET", a.global =! 1)}), n.ajaxTransport ("script", función (a) {if (a.crossDomain) {var b, c = z.head | | n ("head") [0] || z.documentElement; return {send: function (d, e) {b = z.createElement ("script"), b.async =! 0, a.scriptCharset && (b .charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = function (a, c) {(c ||! b.readyState || / loaded | complete / .test (b .readyState)) && (b.onload = b.onreadystatechange = null, b.parentNode && b.parentNode.removeChild (b), b = null, c || e (200, "success"))), c.insertBefore (b , c.firstChild)}, abortar: function () {b && b.onload (void 0,! 0)}}}}); var ad = [], bd = / (=) \? (? = & | $) | \? \? /; n.ajaxSetup ({jsonp: "callback",jsonpCallback: function () {var a = ad.pop () || n.expando + "_" + wc ++; devuélvalo [a] =! 0, a}}), n.ajaxPrefilter ("json jsonp", función ( b, c, d) {var e, f, g, h = b.jsonp! ==! 1 && (bd.test (b.url)? "url": "string" == tipo de b.data &&! (b .contentType || ""). indexOf ("application / x-www-form-urlencoded") && bd.test (b.data) && "data"); return h || "jsonp" === b.dataTypes [ 0]? (E = b.jsonpCallback = n.isFunction (b.jsonpCallback)? B.jsonpCallback (): b.jsonpCallback, h? B [h] = b [h] .replace (bd, "$ 1" + e ): b.jsonp! ==! 1 && (b.url + = (xc.test (b.url)? "&": "?") + b.jsonp + "=" + e), b.converters ["script json "] = función () {return g || n.error (e +" no se llamó "), g [0]}, b.dataTypes [0] =" json ", f = a [e], a [ e] = función () {g = argumentos}, d.siempre (función () {a [e] = f, b [e] && (b.jsonpCallback = c.jsonpCallback, ad.push (e)), g && n.isFunction (f) && f (g [0]), g = f = void 0}), "script"): void 0}), n.parseHTML = function (a, b, c) {if (! a || "string"! = typeof a) return null; "boolean "== typeof b && (c = b, b =! 1), b = b || z; var d = v.exec (a), e =! c && []; return d? [b.createElement (d [ 1])] :( d = n.buildFragment ([a], b, e), e && e.length && n (e) .remove (), n.merge ([], d.childNodes))}; var cd = n .fn.load; n.fn.load = function (a, b, c) {if ("string"! = typeof a && cd) return cd.apply (this, argumentos); var d, e, f, g = this , h = a.indexOf (""); retornar h> = 0 && (d = a.slice (h, a.length), a = a.slice (0, h)), n.isFunction (b)? ( c = b, b = void 0): b && "objeto" == tipo de b && (f = "POST"), g.length> 0 && n.ajajax ({url: a, tipo: f, dataType: "html ", datos: b}). done (función (a) {e = argumentos, g.html (d? n (" <div> ") .append (n.parseHTML (a)). find (d): a)}). complete (c && function (a, b) {g.each (c, e || [a.responseText, b, a])}), this}, n.expr.filters.animated = function (a ) {return n.grep (n.timers, function (b) {return a === b.elem}). length}; var dd = a.document.documentElement; function ed (a) {return n.isWindow ( a)? a: 9 === a.nodeType? a.defaultView || a.parentWindow:! 1} n.offset = {setOffset: function (a, b, c) {var d, e, f, g, h, i, j, k = n.css (a, "posición"), l = n (a), m = {}; "static" === k && (a.style.position = "relative"), h = l.offset (), f = n.css (a, "top"), i = n.css (a, "left"), j = ("absolute" === k || "fixed" = == k) && n.inArray ("auto", [f, i])> - 1, j? (d = l.position (), g = d.top, e = d.left) :( g = parseFloat (f) || 0, e = parseFloat (i) || 0), n.isFunction (b) &&(b = b.call (a, c, h)), null! = b.top && (m.top = b.top-h.top + g), null! = b.left && (m.left = b. left-h.left + e), "using" en b? b.using.call (a, m): l.css (m)}}, n.fn.extend ({offset: function (a) {if (argumentos.longitud) devuelve void 0 === a? esto: this.each (función (b) {n.offset.setOffset (this, a, b)}); var b, c, d = {top: 0 , izquierda: 0}, e = este [0], f = e && e.ownerDocument; if (f) return b = f.documentElement, n.contains (b, e)? (typeof e.getBoundingClientRect! == L && (d = e.getBoundingClientRect ()), c = ed (f), {top: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0), izquierda: d.left + (c.pageXOffset || b.scrollLeft) - (b.clientLeft || 0)}): d}, position: function () {if (this [0]) {var a, b, c = {top: 0, left: 0 }, d = este [0]; devuelve "corregido" === n.css (d, "posición")? b = d.getBoundingClientRect () :( a = this.offsetParent (), b = this.offset ( ), n.nodeName (a [0], "html") || (c = a.offset ()), c.top + = n.css (a [0], "borderTopWidth",! 0), c.left + = n.css (a [0], "borderLeftWidth",! 0)), {top: b.top-c.top-n. css (d, "marginTop",! 0), izquierdo: b.left-c.left-n.css (d, "marginLeft",! 0)}}}, offsetParent: function () {return this.map ( function () {var a = this.offsetParent || dd; while (a &&! n.nodeName (a, "html") && "static" === n.css (a, "position")) a = a. offsetParent; return a || dd})}}), n.each ({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (a, b) {var c = / Y / .test (b); n.fn [a] = función (d) {devolver W (esta, función (a, d, e) {var f = ed (a); devolver void 0 === e? f? b en f? f [ b]: f.document.documentElement [d]: a [d]: void (f? f.scrollTo (c? n (f) .scrollLeft (): e, c? e: n (f) .scrollTop () ): a [d] = e)}, a, d, argument.length, null)}}), n.each (["top", "left"], function (a, b) {n.cssHooks [ b] = Mb (l.pixelPosition,función (a, c) {return c? (c = Kb (a, b), Ib.test (c)? n (a) .position () [b] + "px": c): void 0}) }), n.each ({Altura: "altura", Ancho: "ancho"}, función (a, b) {n.each ({relleno: "interno" + a, contenido: b, "": "externo "+ a}, función (c, d) {n.fn [d] = función (d, e) {var f = argumentos.longitud && (c ||" booleano "! = tipo de d), g = c || (d ===! 0 || e ===! 0? "margin": "border"); return W (this, function (b, c, d) {var e; return n.isWindow (b)? b.document.documentElement ["client" + a]: 9 === b.nodeType? (e = b.documentElement, Math.max (b.body ["scroll" + a], e ["scroll" + a ], b.body ["offset" + a], e ["offset" + a], e ["client" + a])): void 0 === d? n.css (b, c, g) : n.style (b, c, d, g)}, b, f? d: void 0, f, null)}})}), n.fn.size = function () {return this.length}, n.fn.andSelf = n.fn.addBack, "función"== typeof define && define.amd && define ("jquery", [], function () {return n}); var fd = a.jQuery, gd = a. $; return n.noConflict = function (b) {return a. $ === n && (a. $ = gd), b && a.jQuery === n && (a.jQuery = fd), n}, tipo de b === L && (a.jQuery = a. $ = n), n} );